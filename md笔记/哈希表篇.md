# 第六天

## 基础复习

##### 哈希表是它通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 `key`，则可以在 𝑂(1) 时间内获取对应的值 `value`。

##### 常用的哈希表有set和map

| **集合** | 底层实现 | **是否有序** | **数值是否可以重复** | **能否更改数值** | **查询效率** | **增删效率** |
|  ----  | ----   | ----   | ----   | ----   | ----   | ----   |
| std::set           | 红黑树   | 有序         | 否                   | 否               | O(log n)     | O(log n) |
| std::multiset      | 红黑树   | 有序         | 是                   | 否               | O(log n)     | O(log n) |
| std::unordered_set | 哈希表   | 无序         | 否                   | 否               | O(1)         | O(1) |

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

#### 详细信息可见 <a href="https://www.hello-algo.com/chapter_hashing/hash_map/">"Hello 算法"</a>

## 哈希表：1.有效字母异位词

#### 对应力扣 <a href="https://leetcode.cn/problems/valid-anagram/description/">242.有效字母异位词</a>

##### 这道题并不复杂，不会哈希表用双层for循环也能解决；这里因为数据量比较少，只有26个英文字母，所以综合考虑效率我们可以使用数组作为哈希表，因为对于int数组而言只能存储整形数据，而字母有ASCII码，所以我们把每个字母-'a'，这样就可以分别得到各个字母的数组下标，从而统计字母个数；因为要比较两个字符串字母个数是否相等，我们可以遍历第二个字符串，遇到相同的字母哈希表对应字母的个数减一；最后我们只用检查新的哈希表所有字母个数是否为0就能知道两个字符串字母个数是否相等

```c++
bool isAnagram(string s, string t) {
    //使用数组做哈希表
    //一定要做初始化
    int hash[26]={0};
    for(char i : s){
        hash[i-'a']++;
    }
    for(char i : t){
        hash[i-'a']--;
    }
    for(int i=0;i<26;i++){
        //如果找到任一一个字母个数不为0直接返回false
        if(hash[i]!=0){
            return false;
        }
    }
    return true;
}
```

## 哈希表：2. 两个数组的交集

#### 对应力扣 <a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349.两个数组的交集</a>

##### 这里的数据量比较少，所以我们可以使用数组当做哈希表，但是因为上一道题使用过了数组，所以我们优先使用unordered_set，这里选择unordered_set的原因是元素不需要排序，这样可以减少时间复杂度

### （1）unordered_set

##### 我们定义一个result_set容器用于接收最后的结果数据，先把num1的元素导入num_set，这时nums1的数据已经完成去重，我们再遍历nums2的元素，并且使用find函数查找，如果num_set能找到与nums2相同的元素，就把这个元素放入result_set，由于函数最后要返回vector容器，我们需要将result_set的元素导入vector并返回

```c++
//使用unordered_set
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int>result_set;
    unordered_set<int>num_set(nums1.begin(),nums1.end());
    for(int i:nums2){
        if(num_set.find(i)!=num_set.end()){
            result_set.insert(i);
        }
    }
    return vector<int>(result_set.begin(),result_set.end());
}
```

### （2）数组

##### 这里因为元素量比较少，我们可以使用数组作为哈希表，他的速度肯定是要快于unordered_set

##### 我们将nums1的元素导入hash数组，并且把每个元素的出现次数设置为1，从而达到去重的效果；然后遍历nums2的元素，如果当前元素在hash数组中出现过，我们就将这些元素导入result_set，最后的操作与上面一样

```c++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int>result_set;
    int hash[1005]={0};
    for(int i:nums1){
        hash[i]=1;
    }
    for(int i:nums2){
        if(hash[i]==1){
            result_set.insert(i);
        }
    }
    return vector<int>(result_set.begin(),result_set.end());
}
```

### 总结

##### 本题既可以使用set，也可以使用数组，那么什么有什么区别呢？

##### 当数据量比较大或者数据跨度比较大的时候我们可以选择set或map，比如有1万个元素，或者只有3个元素，但是这三个元素分别是{1,2,10000}；其余情况，数据量小的时候我们可以使用数组，并且数组的速度是要快于set和map的。

