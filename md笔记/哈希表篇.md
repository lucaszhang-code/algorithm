# 第六天

## 基础复习

##### 哈希表是它通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 `key`，则可以在 𝑂(1) 时间内获取对应的值 `value`。

##### 常用的哈希表有set和map

| **集合** | 底层实现 | **是否有序** | **数值是否可以重复** | **能否更改数值** | **查询效率** | **增删效率** |
|  ----  | ----   | ----   | ----   | ----   | ----   | ----   |
| std::set           | 红黑树   | 有序         | 否                   | 否               | O(log n)     | O(log n) |
| std::multiset      | 红黑树   | 有序         | 是                   | 否               | O(log n)     | O(log n) |
| std::unordered_set | 哈希表   | 无序         | 否                   | 否               | O(1)         | O(1) |

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

#### 详细信息可见 <a href="https://www.hello-algo.com/chapter_hashing/hash_map/">"Hello 算法"</a>

## 哈希表：1.有效字母异位词

#### 对应力扣 <a href="https://leetcode.cn/problems/valid-anagram/description/">242.有效字母异位词</a>

##### 这道题并不复杂，不会哈希表用双层for循环也能解决；这里因为数据量比较少，只有26个英文字母，所以综合考虑效率我们可以使用数组作为哈希表，因为对于int数组而言只能存储整形数据，而字母有ASCII码，所以我们把每个字母-'a'，这样就可以分别得到各个字母的数组下标，从而统计字母个数；因为要比较两个字符串字母个数是否相等，我们可以遍历第二个字符串，遇到相同的字母哈希表对应字母的个数减一；最后我们只用检查新的哈希表所有字母个数是否为0就能知道两个字符串字母个数是否相等

```c++
bool isAnagram(string s, string t) {
    //使用数组做哈希表
    //一定要做初始化
    int hash[26]={0};
    for(char i : s){
        hash[i-'a']++;
    }
    for(char i : t){
        hash[i-'a']--;
    }
    for(int i=0;i<26;i++){
        //如果找到任一一个字母个数不为0直接返回false
        if(hash[i]!=0){
            return false;
        }
    }
    return true;
}
```

## 哈希表：2. 两个数组的交集

#### 对应力扣 <a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349.两个数组的交集</a>

##### 这里的数据量比较少，所以我们可以使用数组当做哈希表，但是因为上一道题使用过了数组，所以我们优先使用unordered_set，这里选择unordered_set的原因是元素不需要排序，这样可以减少时间复杂度

### （1）unordered_set

##### 我们定义一个result_set容器用于接收最后的结果数据，先把num1的元素导入num_set，这时nums1的数据已经完成去重，我们再遍历nums2的元素，并且使用find函数查找，如果num_set能找到与nums2相同的元素，就把这个元素放入result_set，由于函数最后要返回vector容器，我们需要将result_set的元素导入vector并返回

```c++
//使用unordered_set
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int>result_set;
    unordered_set<int>num_set(nums1.begin(),nums1.end());
    for(int i:nums2){
        if(num_set.find(i)!=num_set.end()){
            result_set.insert(i);
        }
    }
    return vector<int>(result_set.begin(),result_set.end());
}
```

### （2）数组

##### 这里因为元素量比较少，我们可以使用数组作为哈希表，他的速度肯定是要快于unordered_set

##### 我们将nums1的元素导入hash数组，并且把每个元素的出现次数设置为1，从而达到去重的效果；然后遍历nums2的元素，如果当前元素在hash数组中出现过，我们就将这些元素导入result_set，最后的操作与上面一样

```c++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int>result_set;
    int hash[1005]={0};
    for(int i:nums1){
        hash[i]=1;
    }
    for(int i:nums2){
        if(hash[i]==1){
            result_set.insert(i);
        }
    }
    return vector<int>(result_set.begin(),result_set.end());
}
```

### 总结

##### 本题既可以使用set，也可以使用数组，那么什么有什么区别呢？

##### 当数据量比较大或者数据跨度比较大的时候我们可以选择set或map，比如有1万个元素，或者只有3个元素，但是这三个元素分别是{1,2,10000}；其余情况，数据量小的时候我们可以使用数组，并且数组的速度是要快于set和map的。

# 第七天

## 哈希表：3.两数相加

#### 对应力扣 [1.两数之和](https://leetcode.cn/problems/two-sum/submissions/528153671/)

##### 本题是力扣的第一道题，单纯从解题方法上并不困难，一般人使用双层for循环也可以解决；在这里使用哈希表解题

##### 我们定义一个哈希表unordered_map，为什么不使用set或map的原因是我们需要存储已经遍历过的元素，只用map有键值对，value对应数组元素的值，key对应数组的下标；况且存储元素不需要排序，所以采用unordered_map

##### 本题的思路是便利nums的元素，比如第一个元素nums[0]=2,target=9，我们就要在哈希表中寻找是否存储过target-nums[0]，也就是7，如果哈希表中存在value为7的对，我们就分别返回他们的下标，如果没有，我们就讲当前元素也就是nums[0]存进哈希表，继续遍历nums下一个元素

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> map;
    for(int i=0;i<nums.size();i++){
        int s=target-nums[i];
        auto iter=map.find(s);
        if(iter!=map.end())
            return {iter->second,i};
        map.insert(pair<int,int>(nums[i],i));
    }
    return{};
}
```

## 哈希表：4.四数相加II

#### 对应力扣 [454.四数相加II](https://leetcode.cn/problems/4sum-ii/)

##### 本题虽然真的可以用四层for循环，但是在力扣中会超时，所以我们不得不思考另一种方法

##### 四个数组，从每个数组中各取一个元素，让这四个元素相加等于0，我们可以把四个数组分成两组，一组两个数组进行两层for循环，得到所有的相加之和，并把他们存储在hash表中，key对应两数之和，value对应个数，这时我们再将整合过得hash表拿在第二组两组数组nums3，nums4中进行双层for循环，并寻找在hash表中是否存在0-num3-num4,（因为四个数相加等于0，分成两组，如果一组的和为num，那为了符合条件，另一组应该是0-num），如果存在，让计数器count+=hash表对应的value。为什么要分成两组，一组两个数组，不能一组1个数组，另一组3个数组吗？分成两组两个数组的时间复杂的都是O(n^2)，相加还是O(n^2)，如果分成1个数组和3个数组，那时间复杂度是O(n)+O(n^3)=O(n^3)是大于O(n^2)

```c++
    unordered_map<int,int> add(vector<int>& nums1,vector<int>& nums2){
        unordered_map<int,int>mp;
        for(int num1:nums1){
            for(int num2:nums2){
                mp[num1+num2]++;
            }
        } 
        return mp;
    }

    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> mp=add(nums1,nums2);
        int count=0;
        for(int num3:nums3){
            for(int num4:nums4){
                if(mp.find(0-num3-num4)!=mp.end()){
                    count+=mp[0-num3-num4];
                }
            }
        }
        return count;
    }
```



