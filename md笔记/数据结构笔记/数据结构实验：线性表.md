### 顺序线性表数据结构定义如下：

```c	
#include <stdio.h>
#include <stdlib.h>

/*此处是顺序线性表数据结构定义*/
typedef int DataType;	//把int类型用DataType表示
struct seqList
{
  int MAXNUM;//用于记录顺序线性表中能存放的最大元素个数的 整型 MAXNUM   这是申请内存空间的最大值
  int curNum;//用于存放顺序线性表中数据元素的个数  整型  curNum		这是当前线性表的空间，你可以理解成数组长度
  DataType *element;//用于存放顺序线性表数据元素的连续空间的起始地址  
};
typedef struct seqList *PseqList;	用*PseqList指针表示seqList结构体类	
```



### 本关的编程任务是补全文件中createNullList_seq函数，以实现初始化一个空的顺序线性表的要求。

```c
//第一关
PseqList createNullList_seq(int m)
{
    //创建一个空的顺序线性表，能存放的最大元素个数为 m
    
 	//若m=0，则返回NULL 
    //如果申请的内存空间是0，直接返回NULL
    if (m == 0) 
        return NULL;
    
    /*
	malloc() 是 C 标准库中的函数，用于动态分配内存。
    它接受一个参数，即要分配的内存大小（以字节为单位），并返回一个指向新分配内存起始地址的指针
    使用方法：内存起始地址指针=(数据类型 指针)malloc(分配的空间大小);
    这里分配的空间大小是sizeof(struct seqList)
    删除方法：使用free(内存起始地址指针)释放内存空间
    */
    
    /*
    多说一嘴，在c++中是通过new来分配内存空间
    使用方法:内存起始地址指针=new(分配的空间大小);
    比如：
    	int* ptr = new int; // 分配一个整数大小的内存空间
    	int* arr = new int[10]; // 分配一个包含10个整数的数组的内存空间
	删除方法：
		delete ptr; // 释放之前分配的单个整数内存空间
		delete[] arr; // 释放之前分配的整数数组内存空间
    */
    
    //结构体分配内存空间
    //其中arr是结构体指针
    PseqList arr = (PseqList)malloc(sizeof(struct seqList));

    // 如果内存分配失败，返回NULL
    //如果分配后的arr还是NULL
    if (arr == NULL)
        return NULL;

    //数组分配空间
    //其中arr->element是数组首地址
    arr->element = (DataType*)malloc(m * sizeof(DataType));
    
    // 检查内存分配是否失败
    if (arr->element == NULL) { 
        free(arr); 
        return NULL;
    }

    arr->MAXNUM = m;
    arr->curNum = 0; 
    
    return arr; 
} 
```

### 在顺序线性表中下标为p位置、p位置之前、p位置之后插入数据元素

```c++
//第二关
int isFullList_seq(PseqList L) {
  //先判断L是否存在
    if (L == NULL) 
        return 0; 
    //bool，如果当前的curNum==MAXNUM返回1
    return (L->curNum == L->MAXNUM); 
}

int insertP_seq(PseqList L , int p ,int x)
{
  	// 在线性表L中下标为p的位置插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
  	//如果线性表满了， 还需输"list is full"的提示
  	//如果插入位置非法，需输出提示"position is illegel" 
    if (isFullList_seq(L)) {
        printf("list is full");
        return 0;
    }
    
    //判断p位置是否合法，他不能小于0，也不能大于数组的长度curNum
    if (p < 0 || p > L->curNum) {
        printf("position is illegel");
        return 0;
    }
    
    // 在下标为p的位置插入元素x
    //比如1 2 3，我么想在下标为1的地方插入0，那么此时包括1位置后面的所有元素都会向后移一位，为了防止前面的元素把后面覆盖，我们从末尾进行移动操作
    for (int i = L->curNum - 1; i >= p; i--) {
        L->element[i + 1] = L->element[i]; 
    }
    //填入元素
    L->element[p] = x; 
    //长度加一
    L->curNum++; 
    
    return 1; 
}

int insertPre_seq(PseqList L , int p ,int x)
{
 	// 在线性表L中下标为p的位置的前面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
	//提示：直接调用insertP函数实现即可    
    return insertP_seq(L, p-1, x);
    
}

int insertPost_seq(PseqList L , int p ,int x)
{
 	// 在线性表L中下标为p的位置的后面插入数据元素x，若下标p非法或线性表已满无法插入数据，返回0；插入成功返回值为1
	//提示：直接调用insertP函数实现即可    
     return insertP_seq(L, p+1, x);
}

void printList_seq(PseqList L)
{
    //逐个输出线性表的元素，相邻的两个数据元素之间以一个空格为分隔符隔开
 for (int i = 0; i < L->curNum; i++) {
     //在c语言中%d是空格，\n是换行
     //对应cout<<" ";和cout<<endl;
        printf("%d ", L->element[i]);
    }
    printf("\n");
}
```

### 本关任务：销毁线性表的实质时实现动态分配的线性表空间回收。

```c
//第三关
int destroyList_seq(PseqList L)
{
    //返回值为销毁的线性表中现有数据元素的个数，若待销毁的线性表不存在，则返回0
   if (L == NULL) // 如果线性表不存在，返回0
        return 0;   
    int numElements = L->curNum; // 记录线性表中现有数据元素的个数
    
    // 释放元素数组的内存
    free(L->element); 
    // 释放线性表结构体的内存
    free(L);
    return numElements; // 返回销毁的线性表中现有数据元素的个数
}
```

### 本关任务： 1.在顺序线性表中查找第一个值为x的元素下标。 2.在顺序线性表中查找某个位置pos处的数据元素

```c
//第四关
int locate_seq(PseqList L,int x)
{//在顺序表L中查找给定值x首次出现的位置，若不存在给定值，则返回-1
    for (int i = 0; i < L->curNum; i++) {
        if (L->element[i] == x) {
            return i; 
        }
    }
    return -1; 
}

DataType locatePos_seq(PseqList L,int pos)
{// 在顺序表L中查找指定位置pos处的数据元素，若位置非法，则返回第0个数据元素
    if(pos<0 || pos>L->curNum)
    return L->element[0];

    return L->element[pos];
}
```

### 本关任务： （1）在顺序表L中删除下标pos处的数据元素 （2）在顺序表L中删除与参数x值相同的数据元素

```c
//第五关
int deletePos_seq(PseqList L,int pos)
{//在顺序表L中删除与下标pos处的数据元素，若pos非法，则返回-1；否则返回1
     if (pos < 0 || pos >= L->curNum)
        return -1; 

    // 删除指定位置的数据元素
    //也就是让后面的元素覆盖前面的元素
    for (int i = pos; i < L->curNum - 1; i++) {
        L->element[i] = L->element[i + 1]; 
    }

    L->curNum--; 
    return 1; 

}

int delete_seq(PseqList L,int x)
{//在顺序表L中删除与参数x值相同的数据元素，返回删除数据元素的个数
  //可以使用之前已完成的操作
  int count=0;
  for(int i=0;i<L->curNum;i++)
  {
    if(L->element[i]==x)
    {
        deletePos_seq(L, i); 
        count++;
        //这个地方因为当前位置的元素被删除后有可能新的元素还是x，为了防止错过当前位置，我们还是需要i--，再次检查这个下标上的元素是否符合条件
        //有点类似于erase函数返回新的迭代器
        i--; 
    }
  }
  return count;
}
```

### 本关任务： （1）使用将顺序表L中值为x的数据元素替换为y； （2）此处假设线性表中的元素用于表示集合，不考虑线性表中元素的位置，移除线性表中的所有重复元素；不要使用额外的数组空间，必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```c
//第六关
void replace_seq(PseqList L,int x,int y)
{//将顺序表L中值为x的数据元素替换为y
  for(int i=0;i<L->curNum;i++)
  {
    if(L->element[i]==x)
    L->element[i]=y;
  }
}

void delDuplicate_seq(PseqList L)
{//移除线性表中的所有重复元素；不要使用额外的数组空间，必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成
  //使用常规删除即可，已修改测试用例
  //注意！c语言没有bool类型
  int flag=0;
      for (int i = 0; i < L->curNum - 1; i++) {
        for (int j = i + 1; j < L->curNum; j++) {
            if (L->element[j] == L->element[i]) {
                deletePos_seq(L, j);    
                flag=1;
            }
        }
        if(flag)
        {
          deletePos_seq(L, i); 
          flag=0;
        }
    }
}
```

