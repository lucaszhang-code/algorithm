# 实验三：队列及应用

#### 头文件，结构体定义

```c
#include <iostream>
using namespace std;
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef char DataType;
 

//队列数据元素结构
typedef struct node
{
  //每个节点的数据
   DataType info;
  //节点指针
   struct node *next;
}QueueData;

typedef struct queueRecord{
  //队列的头和尾
   QueueData  *front, *rear ;
 }LINKQUEUE;

typedef struct queueRecord *PLinkQueue;
```
#### 创建一个空队列，实质：生成一个LINKQUEUE类型的结点，并给front 和 rear 成员赋值

```c
PLinkQueue createEmptyQueue_link( )
{
   //创建一个空队列，实质：生成一个LINKQUEUE类型的结点，并给front 和 rear 成员赋值
    //请在此处填写代码，完成相应功能
    /*-------begin----------*/
  //开辟空间，创建队列
     PLinkQueue queue = new queueRecord;  
  //判断队列是否为空
    if (queue == nullptr) {              
        return nullptr;
    }
  //队列头和尾的初始化
    queue->front = nullptr;  
    queue->rear = nullptr;   
    return queue;   
    /*-------end----------*/
}
```
#### 判定队列是否为空，实质： 看队列的front指针是否为空，若为空，则队列为空

```c
int isEmptyQueue_link(PLinkQueue  queue)
{ //判定队列是否为空，实质： 看队列的front指针是否为空，若为空，则队列为空
    
  //请在此处填写代码，完成相应功能
    /*-------begin----------*/
  //判断front指针是否为空
    if(queue->front == nullptr)
      return 1;
    else
      return 0;
    /*-------end----------*/
}
```
#### 将数据元素x插入队尾。实质：生成一个struct node类型的结点，并给相应成员赋值后插入队尾

```c
 void enQueue_link(DataType x, PLinkQueue queue)
 {
   //将数据元素x插入队尾。实质：生成一个struct node类型的结点，并给相应成员赋值后插入队尾
    //请在此处填写代码，完成相应功能
    /*-------begin----------*/
     // 创建新节点
    QueueData *newNode = (QueueData *)malloc(sizeof(QueueData));
    if (newNode == NULL) { 
        return;
    }
   //插入节点的数值是x
    newNode->info = x; 
   //插入节点是队尾，指向NULL
    newNode->next = NULL; 

   //判断：如果队尾为空，也就是队列中没有节点，将头结点和尾节点都赋给插入节点
    if (queue->rear == NULL) { 
        queue->front = queue->rear = newNode; 
    } 
   //如果队列中有值，让队尾的下一个节点指向插入节点，再让插入节点作为队尾节点
   else {
        queue->rear->next = newNode; 
        queue->rear = newNode; 
    }    
    /*-------end----------*/
 }
```
#### 本函数的功能是将 struct node 类型的结点插入队尾，与enQueue_link(DataType x, PLinkQueue queue)的区别是，不需要生成结点

```c
void enQueue_link(QueueData *p,PLinkQueue Q)
 {
  //本函数的功能是将 struct node 类型的结点插入队尾，与enQueue_link(DataType x, PLinkQueue queue)的区别是，不需要生成结点
  
     //请在此处填写代码，完成相应功能
    /*-------begin----------*/
  //跟上面的代码没什么区别，主要是函数直接传入了新的节点而不是值
     p->next = NULL; 
    if (Q->rear == NULL) {  
        Q->front = Q->rear = p;  
    } 
  else {
        Q->rear->next = p;  
        Q->rear = p;  
    }
    /*-------end----------*/
 }
```
#### 出队，实质： 取出Q队列的队首结点，返回该结点的数据元素，并将该结点使用enQueue_link(QueueData *p,PLinkQueue Q)插入队尾

```c
DataType deQueue_link(PLinkQueue Q)
 {
     //出队，实质： 取出Q队列的队首结点，返回该结点的数据元素，并将该结点使用enQueue_link(QueueData *p,PLinkQueue Q)插入队尾
     //本函数为针对本实验特殊设计，可实现秘钥的循环使用
     //请在此处填写代码，完成相应功能
    /*-------begin----------*/
    if (Q->front == NULL) {  // 如果队列为空，返回0或特定值表示错误
        return 0;  // 根据实际情况，可能需要调整返回值
    }

  	// 暂存队首元素
    QueueData *temp = Q->front;
  	// 获取队首元素数值
    DataType info = temp->info;
  	// 移动头指针到下一个元素
    Q->front = Q->front->next;  
		
  	// 如果队列变空
    if (Q->front == NULL) {
      	// 重置尾指针
        Q->rear = NULL;  
    }
		// 新的队尾元素指向NULL
    temp->next = NULL;
  	// 调用前面的函数，把暂存节点插入队尾
    enQueue_link(temp, Q);  

    return info;  // 返回新的队首元素的数据
    /*-------end----------*/  
 }
```

#### 遍历字符串`src`，将`key`存入队列中，只取队首元素，，用完后把他放在队尾
```c
void decrypt(char src[], char key[], char dest[])
 {
 	/*  参数： src 放的是源文 ； key 放的是秘钥 ； dest 放加密后的密文
       加密函数： 步骤提示
       1. 初始化一个空队列Q
       2. 将key数组的元素逐个插入队列Q
       3. 逐个访问src数组的源文，并加密， 使用deQueue_link(Q)函数可得到队首秘钥，并使秘钥循环使用
       闯关提示：如果输出一样的加密后字符串，但是无法过关，是因为加密后的字符串尾部少了\0,加上\0即可
    */
    PLinkQueue queue = createEmptyQueue_link();
    for (int i = 0; key[i] != '\0'; i++) {
        enQueue_link(key[i] - '0', queue);  
    }

   int i = 0;
    for ( i = 0; src[i] != '\0'; i++) {
        DataType move = deQueue_link(queue);
        dest[i] = src[i] + move;
    }
    dest[i] = '\0';  
 }
```

#### 这里也提供C++代码

```c++
void decrypt(string &str , string &key){
    queue<int> que;
    for(char c : key){
        que.push(c - '0');
    }

    for(char c : str){
        int digit = que.front();
        //转换为字符串，要不然就是ASCII值
        cout<< static_cast<char>(c + digit);
        que.pop();
        que.push(digit);
    }
}
```

