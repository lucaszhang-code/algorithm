# 数据结构试验：栈应用

#### 头文件和结构体

```c
#ifndef _STACK_H_
#define _STACK_H_

#include <iostream>
using namespace std;

typedef int DataType;

//采用链式栈
struct node{
    //数据元素
    DataType element;  
    //指向下一个数据元素的指针
    struct node *next; 
};

typedef struct node *PtrToNode;
typedef struct node *Stack;
```

####  函数名：isEmpty

####  函数功能：判定栈是否为空

####  函数参数：栈头结点指针

####  返回值：若栈为空，则返回1，否则返回0

```c
int isEmpty(Stack s)
{
    return (s == NULL);
}
```
#### 函数名：createStack 
####   函数功能：创建一个空栈，实际上只需要初始化栈头结点 
####   函数参数：无 
####   返回值：栈头结点指针 
```c
Stack createStack(void)  
{
	Stack s ;
	s =new struct node;
	s->next = NULL;
	s->element =0;
	return s;
}
```

#### 函数名：push

####  函数功能：向栈中压人一个数据元素值为x

####  函数参数：待压栈的数据元素，栈头结点指针

####  返回值：无

```c
void push(DataType x, Stack &s)
{
    //new一个暂存的元素
    PtrToNode temp = new node;  
    //temp的值为x
    temp->element = x;
    //temp成为新的头指针，它指向原来旧的头指针
    temp->next = s;     
    //新的头指针是temp
    s = temp;                  
}
```

#### 函数名：pop

####  函数功能：弹出栈顶元素并返回元素值

####  函数参数：栈头结点指针

####  返回值：栈顶元素的值

```c
DataType pop(Stack &s)
{
    //判断栈是否为空
    if (isEmpty(s)) {
        return -1;  
    } 
    else {
        //因为栈顶元素会被弹出，用一个temp元素暂存
        PtrToNode temp = s;  
        //用poppedValue记录栈顶元素的值
        DataType poppedValue = s->element; 
        //把栈顶元素赋给旧栈顶元素的下一个元素
        s = s->next; 
        //删除旧栈顶元素，也就是temp
        delete temp;
        //返回旧栈顶元素的值
        return poppedValue;        
    }
}
```

#### 函数名：convert10to2

####  函数功能：将十进制数x转换为二进制并输出 

####  函数参数：十进制数x 

####  返回值：无 

```c
//代码很好理解，这里不做过多的讲解
void convert10to2(int x){
    Stack s = createStack();  

    while (x > 0) {
        int digit = x % 2;  
        push(digit, s);     
        x /= 2;             
    }

    while (!isEmpty(s)) {    
        int num = pop(s);
        cout << num;
    }
    cout << endl;  
 }
```

#### 这里附上C++代码

```c++
void convert10to2(int x){
    stack<int> st;
    while(x > 0){
        int digit = x % 2;
        st.push(digit);
        x /= 2;
    }

    while(!st.empty()){
        int num = st.top();
        cout<<num;
        st.pop();
    }
}
```

#### 函数名：`inToPost`

#### 函数功能：将中缀表达式转换为后缀表达式输出 

####  函数参数：中缀表达式，放在字符数组中 

####  返回值：无 

##### 本题具有相当的难度，主要集中在以下两点

##### 1. 不能单纯的用`char`去分割，要不然13会被分割为1和3，要分割正确的数字

##### 2. 确定操作符的优先级

```c
void inToPost(char *expression)
{
   //在此处填写代码，完成中缀表达式转换为后缀表达式并输出
   /**********  Begin  **********/
   Stack s = createStack(); // 创建一个栈
    push('#', s);  // 初始化栈，压入一个优先级最低的元素

    for (int i = 0; expression[i] != '\0'; i++) {
        char token = expression[i];

        // 局部函数或内联条件判断来决定优先级 Lambda表达式
        auto precedence = [](char op) -> int {
            switch (op) {
                case '*':
                case '/':
                    return 2;
                case '+':
                case '-':
                    return 1;
                default:
                    return 0;
            }
        };

        if (isdigit(token)) { 
            cout << token;
            // 检查下一个字符是否也是数字，如果不是，则添加空格
            if (expression[i + 1] == '\0' || !isdigit(expression[i + 1])) {
                cout << " ";
            }
            // 如果是左括号
        } 
        else if (token == '(') { 
            push(token, s);
            // 如果是右括号
        } 
        else if (token == ')') { 
            while (top(s) != '(') {
                cout << pop(s) << " ";
            }
            pop(s); 
        } 
        else { 
            while (!isEmpty(s) && precedence(top(s)) >= precedence(token)) {
                cout << pop(s) << " ";
            }
            push(token, s);
        }
    }

    // 弹出所有剩余的操作符
    while (!isEmpty(s) && top(s) != '#') {
        cout << pop(s) << " ";
    }
    cout << endl;
   /**********  End  **********/
}
```

#### 这里着重以C++代码进行讲解

##### 因为头歌似乎无法读取自己创立的外部函数，所以如果我们要自己建函数只能使用匿名函数，也就是`Lambda`表达式

```c++
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
    string str, output;
    getline(cin, str);
    stack<char> st;

    // Lambda 表达式，用于检查字符是否为数字
    auto isDigit = [](char ch) -> bool {
        return ch >= '0' && ch <= '9';
    };

    // Lambda 表达式，用于确定操作符的优先级
    auto precedence = [](char op) -> int {
        switch (op) {
            case '*':
            case '/':
                return 2;
            case '+':
            case '-':
                return 1;
            default:
                return 0;
        }
    };

    // 遍历字符串
    for (int i = 0; i < str.size(); i++) {
        // 如果遇到空格自动跳过
        if (str[i] == ' ') continue;

        // 判断当前遍历的元素是不是数字
        if (isDigit(str[i])) {
            // 如果是，把他添加到output中
            output += str[i];
            // 检查下一个字符是否也是数字，如果不是或者是字符串的末尾，则添加空格
            // 这里偷懒了，因为测试案例中最多只有两位数，所以我只判断数字元素的后一个元素是不是数字
            // 如果位数不固定，得用while去做了
            if (i + 1 == str.size() || !isDigit(str[i + 1])) {
                output += " ";
            }
        }
        //如果当前元素是左括号，就进栈
        else if (str[i] == '(') {
            st.push(str[i]);
        }
        //如果遇到右括号
        else if (str[i] == ')') {
            // 要保证栈不为空，且栈顶元素是左括号（代表前面有左括号进栈）
            // 使用while循环，让栈所有元素出栈
            while (!st.empty() && st.top() != '(') {
                // 栈顶元素赋值给output
                output += st.top();
                // 中间加空格
                output += " ";
                // 栈顶元素出栈
                st.pop();
            }
            // 当栈为空了弹出左括号
            if (!st.empty()) st.pop(); 
        }
        // 对于不是左右括号的情况
        else {
            // 如果当前符号的优先级小于栈顶元素（符号）的优先级
            while (!st.empty() && precedence(st.top()) >= precedence(str[i])) {
                output += st.top();
                output += " ";
                st.pop();
            }
            // 当前元素（符号）入栈
            st.push(str[i]);
        }
    }

    // 弹出所有剩余的操作符
    while (!st.empty()) {
        output += st.top();
        output += " ";
        st.pop();
    }

    cout << output << endl;
    return 0;
}

```

