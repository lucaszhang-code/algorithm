### 本关任务：完成创建一个带表头的空链表的操作。

```c
//第一关
struct node
{
    //此处填写代码，定义链表结点类型，包含一个存放整型数据的 data 成员，和一个指向下一个结点的next成员
    int data;
    struct node *next;
};

struct node *mycreateList()
{
    //此处填写代码，创建一个只有一个头结点的空链表，头节点的数据域赋值为0，并将表头结点的地址返回
    struct node *head=(struct node*)malloc(sizeof(struct node));
    head->data=0;
    head->next=NULL;
    return head;
}
```

#### 顺表写一下c++的链表初始化

##### 详细信息可以在<a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/">“Hello 算法”</a>链表章节了解

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

### 本关任务： 1.编写一个能向表尾插入结点的函数； 2.编写一个能在表头插入结点的函数； 3.编写一个能遍历链表并输出链表各结点数据元素的函数;

![链表插入顺序](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_insert_node.png)

```c
//第二关代码

void myinsertHead(struct node * head, int insData )
{
	/*在此处完成任务，实现在head为表头d 链表的头插数据元素insData的功能*/
	//begin
    //上一章节讲过了malloc函数的用法，这里不做讲述
    struct node* p=(struct node*)malloc(sizeof(struct node));
    //关于链表的插入顺序很有讲究，可以见上面的图
    p->data=insData;
    p->next=head->next;
    head->next=p;
	//end 
}

void myinsertTail(struct node *  head , int insData )
{
	/*在此处完成任务，在head为表头的单链表表尾插入数据元素insData*/
	//begin
    struct node* p=(struct node*)malloc(sizeof(struct node));
    p->data=insData;
    p->next=NULL;
    //循环遍历到链表尾巴
	while(head->next!=NULL)
   {
       head=head->next;
   }
   head->next=p;
	//end 	
}

void myprintList(struct node *L)
{
     /*在此处完成任务，输出head为表头链表中的数据，每输出一个数据换一行*/
	//begin
	while(L->next!=NULL)
    {
        printf("%d\n",L->data);
        L=L->next;    
    }
	//end 
    
}
```

### 本关任务：完成算法，能实现将链表中的数据元素逆置。

##### 这道题其实本身就有点问题，他给的数据第一个虽然是头结点，但是我们的交换函数还是会涉及它，导致最后打印出来的数据有问题，会多一个0

##### 这里仅给出思路，*不提供正确代码*，以下代码为c++代码

##### 我们采用双指针方法

##### 我们定义两个指针pre和cur用于定位两个需要交换的节点。关于初始化cur毫无疑问就是当前的头结点，但头结点前面是没有节点的，所以我们使pre指向nullptr

```c++
ListNode* cur=head;
ListNode* pre=NULL;
```

##### 我们进行的操作是让cur->next=pre,然后双指针前进，这里有一个问题是我们让cur->next=pre后，无法找到原来cur->next节点，所以我们需要创建一个tmp指针去接收旧的cur->next，关于cur和pre的代码顺序也有讲究，我们应该让pre先等于cur，再让cur=tmp，如果顺序反了，会让pre直接到tmp的位置

```c++
//双指针
ListNode* reverseList(ListNode* head) {
    ListNode* cur=head;
    ListNode* pre=NULL;
    while(cur)
    {
        ListNode* tmp=cur->next;
        cur->next=pre;
        pre=cur;
        cur=tmp;
    }
    return pre;
}
```

### 本关任务：查找符合条件的结点，并将该结点的值与前驱结点的值交换。

```c
//第四关代码
int locateAndChange( struct node *L, int data)
 {
    //请在此处填入代码，在头结点为L的链表中查找 与data值相等的第一个结点，若能找到该结点，则将该结点的值与前驱结点的值交换
    //若未找到与data值相等的结点，则返回值为-1，若找到的结点无前驱结点，则返回值为0，否则返回值为前驱结点的值
 	//begin
    struct node* cur = L;
    struct node* prev = NULL;
    
    while (cur != NULL) {
        if (cur->data == data) {
            //头结点
            if (prev == NULL) 
                return 0; 
            else 
            { 
                //交换值操作
                int temp = prev->data;
                prev->data = cur->data;
                cur->data = temp;
                return temp; 
            }
        }
        //双指针前进
        prev = cur;
        cur = cur->next;
    }
    // 没有找到与给定数据值相等的节点
    return -1; 
 	 
	//end 
 }
```

### 链表的结点所占空间是动态分配的堆空间，程序员应在退出程序时释放动态分配的空间。

```c
//第五关代码
int destroyList(struct node *L)
{
  //请在此处填写代码，实现将链表L的结点空间回收
 //返回值为回收结点的个数，含头结点在内  
    int count = 0;
    struct node* cur = L;
    struct node* nextNode;

    while (cur != NULL) {
        //注意顺序
        nextNode = cur->next; 
        free(cur); 
        //节点前进
        cur = nextNode; 
        count++;
    }

    L = NULL; 
    return count;
}

```
