<h1>第一天</h1>

<h4>（一）数组：二分查找法
<h6>对应力扣 <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找
  </a></h6>


<h6>定义三个变量left、right、middle，顾名思义，left指数组左边的下标，right指数组右边的下标，middle代表正中间的下标(left+right)/2；</h6>
<h6>初始情况，left=0,right=数组长度-1</h6>

<h6>每次target值都与middle进行比较，如果比middle大，代表target在数组的右侧，此时移动left的位置，使他等于当前middle+1的位置，为什么不是middle的位置？因为我们这个范围是一个闭区间，如果我们吧left移到middle的位置，此时程序还会再从middle位置开始找，但是target并不在middle位置，因此我们没有必要将left移动到middle位置，而是应该移动到middle+1的位置；如果target小于middle，代表target在数组的左侧，此时将right移动到middle-1的位置；如果target=middle，则直接输出当前middle的值就可以了。
</h6>
<h6>在while循环完，如果都没有使target=middle，则输出-1，代表没找到target</h6>


```c++
int search(vector<int>& nums, int target)
{
    int left=0;
    int right=nums.size()-1;
    while(left<=right)
    {
      	//这个地方加上left是防止middle溢出
        int middle=left+(right-left)/2;
        if(nums[middle]>target)
        {
            right=middle-1;
        }
        else if(nums[middle]<target)
        {
            left=middle+1;
        }
        else
        {
            return middle;
        }
    }
    return -1;
}
```

<h4>（二）数组：移除元素</h4>
<h6>对应力扣 <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h6>



<h6>本题使用“双指针”，其实靠erase函数也可以快速实现数组元素的删除，本题目的在于理解erase函数的实现原理；在创建数组时会在内存中开辟一定的空间，删除元素我们是无法删除相应的那个空间，所以c++实现的操作是将后面的值覆盖到前面，虽然空间大小没变，但内置的计数器会执行相应的操作，这就是使用size()函数会返回新的数组长度的原因</h6>
<h6>本题我们的删除操作也是后面的值覆盖给前面，但是这种覆盖操作会使用两层for循环，时间复杂度是O(n^2)，所以我们引入“双指针”只进行一层for循环，减少复杂度 </h6>
<h6>我们定义两个下标，read和write，简单来说read负责找到val，write负责覆盖操作；在for循环中，read如果没有找到val，此时read和write会一起前进，值得注意的一点是，其实write的+1操作是要先于read；如果read找到了val，那么write不会前进，以此实现覆盖操作。最好通过画图的形式验算；当for循环进行完，此时write的位置就是当前新数组的长度，返回即可。</h6>


```c++
int removeElement(vector<int>& nums, int val) {
    int read, write;
    write = 0;
    for (read = 0; read < nums.size(); read++) {
        if (nums[read] != val) {
            nums[write] = nums[read];
            write++;
        }
    }
    return write;
```

<h4>（三）数组：有序数组的平方</h4>


<h6>对应力扣 <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977.有序数组的平方</a></h6>

<h6>本地最简单的做法是吧每一个元素先平方，然后把他们放入一个新数组中，使用sort排序并返回。这里介绍“双指针”方法。因为数组元素是有序排序的，并且元素中会有负数，所以我们易知，平方后最大的元素必定在原始数组的两侧，我们定义两个指针i和j，以此从数组两头开始比较。如果pow(nums[i],2)>pow(nums[j],2)把pow(nums[i],2)放入结果数组result的末尾（result数组一定要初始化，长度与nums相同，再定义一个下标k），然后i++，k--；如果pow(nums[i],2)<=pow(nums[j],2),就把pow(nums[j],2)放在rusult数组末尾，然后j--，k--；直到i<=j跳出循环，返回新数组</h6>

```c++
vector<int> sortedSquares(vector<int>& nums) {
    vector<int>result(nums.size(),0);
    int k=nums.size()-1;
    for(int i=0,j=nums.size()-1;i<=j;)
    {
        if(pow(nums[i],2)>pow(nums[j],2))
        {
            result[k--]=pow(nums[i],2);
            i++;
        }
        else
        {
            result[k--]=pow(nums[j],2);
            j--;
        }
    }
    return result;
}
```