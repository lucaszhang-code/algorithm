# 二叉树篇

## 二叉树分类

##### 二叉树可以分为满二叉树、完全二叉树

***

### 满二叉树

##### 每一层的节点都达到了最大值

![满二叉树](https://www.hello-algo.com/chapter_tree/binary_tree.assets/perfect_binary_tree.png)

##### 节点数量：`2^k-1` k是深度

### 完全二叉树

##### 除了底层之外，其他层节点都是满的，底层是从左到右节点是连续的

![完全二叉树](https://www.hello-algo.com/chapter_tree/binary_tree.assets/complete_binary_tree.png)

##### 其中满二叉树一定是完全二叉树

### 完满二叉树

##### 除了叶节点之外，其余所有节点都有两个子节点

![完满二叉树](https://www.hello-algo.com/chapter_tree/binary_tree.assets/full_binary_tree.png)

### 二叉搜索树

##### 左子树的所有节点都小于中间节点，右子树的所有节点都大于中间节点

![二叉搜索树](https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/binary_search_tree.png)

##### 时间复杂度`O(logn)`

### 平衡二叉搜索树

##### 左子树和右子树的高度的绝对值的差小于等于一

![平衡二叉树](https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png)

##### 在C++中`map`,`set`,`multimap`,`multiset`这些容器都是平衡二叉搜索树，插入某个元素是`O(logn)`，查询某个元素也是`O(logn)`

##### 注意，`unorderedmap`和`unorderedset`底层是`hash`表

## 二叉树存储方式

### 链式存储

##### 通过指针连接节点

### 线性存储

##### 通过字符数组保存二叉树

![线性存储](https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_binary_tree.png)

##### 如上图，要寻找某个节点的左子结点是当前数组的索引i `2i+1`,右子节点是`2i+2`，例如4的左子结点是`2*3+1=7`，对应节点是8，右子节点`2*3+2=8`对应的节点是9.从上图验证也是如此

##### 一般都是使用链式存储的方式存储链表

## 二叉树的定义

##### 结构体部分

```c++
/* 二叉树节点结构体 */
struct TreeNode {
    int val;          // 节点值
    TreeNode *left;   // 左子节点指针
    TreeNode *right;  // 右子节点指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

##### 创建树

```c++
    //root是头结点
    TreeNode *root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    root->left->left->left = new TreeNode(6);
```

## 二叉树的遍历

### 深度优先遍历(DFS)

##### 从一个方向去搜索，一直搜到终点，然后再回退到起点，从另一个方向去搜索

##### 一般采用递归实现

#### 前序遍历

##### 顺序是中左右

##### 理解：先遍历中间节点，再遍历左节点，最后遍历右节点

![递归遍历](https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png)

##### 如上图：先遍历中间节点也就是1，然后遍历左节点也就是左边子树（不一定立即遍历2），此时还是左中右，遍历2，然后4，最后5；左子树遍历完了，该遍历右子树了，依然遵循中左右的顺序，遍历3,6，最后是7.所以按照前序遍历，他的遍历顺序应该是1、2、4、5、3、6、7

```c++
/* 前序遍历递归方法 */
void preOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    // 访问优先级：根节点 -> 左子树 -> 右子树
    vec.push_back(root->val);
    preOrder(root->left);
    preOrder(root->right);
}
```

```c++
/* 前序遍历非递归方法 */
vector<int> preOrder(TreeNode* root) {
    vector<int> result;
    if (root == nullptr) return result;

    stack<TreeNode*> stack;
    stack.push(root);

    while (!stack.empty()) {
        TreeNode *node = stack.top();
        stack.pop();
        result.push_back(node->val);  // 访问节点
        
        //注意！这里是先让右节点入栈，因为stack是后进先出
        if (node->right != nullptr) {
            stack.push(node->right);
        }
        if (node->left != nullptr) {
            stack.push(node->left);
        }
    }

    return result;
}

```

***

#### 中序遍历

##### 顺序是左中右

##### 理解：先遍历左节点，再遍历中间节点，最后遍历右节点

![递归遍历](https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png)

##### 如上图：先遍历左节点也就是左半部分，此时到了2节点的位置，但是遵循左中右的顺序，先不遍历2节点，先遍历4节点，再遍历2，最后是5；此时左子树已经遍历完，遍历中间节点也就是1,；然后遍历右子树，按照相同的顺序，先遍历6,3，最后是7。所以最终的遍历顺序是4、2、5、1、6、3、7

```c++
/* 中序遍历递归方法*/
void inOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    // 访问优先级：左子树 -> 根节点 -> 右子树
    inOrder(root->left);
    vec.push_back(root->val);
    inOrder(root->right);
}
```

```c++
/* 中序遍历非递归方法*/
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }

```

##### 上面代码理解起来确实有难度，我们以左子树也就是4、2、5、1为例子讲解

##### 1作为中间节点进栈，，然后他的左节点2进栈，2的左节点4进栈。此时4没有左节点了，退出while循环；栈顶是4,4出栈，并存入数组，现在栈里面是2、1；然后访问4的右节点，因为4不存在右节点，所以不会进入while循环，取栈顶元素2,2出栈，进数组，然后访问2的右节点5；进入while循环，5进栈，此时栈有5、1；5不存在左节点，所以退出循环，栈顶元素5出栈，进数组；5不存在左节点，不会进入while循环，此时的栈顶元素是1,1出栈，进数组，访问1的右节点…… 后面就以此类推了。

#### 后序遍历

##### 顺序是左右中

##### 理解：先遍历左节点，再遍历右节点，最后遍历中间节点

![递归遍历](https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png)

##### 如上图：先遍历左节点也就是左半部分，此时到了2节点的位置，但是遵循左右中的顺序，先不遍历2节点，先遍历4节点，再遍历5，最后是2；此时左子树已经遍历完，该遍历右子树了，按照之前的顺序左右中，遍历6,7最后是3.最后遍历中间节点1.所以最终的遍历顺序是4、5、2、6、7、3、1

```c++
/* 后序遍历递归方法 */
void postOrder(TreeNode *root) {
    if (root == nullptr)
        return;
    // 访问优先级：左子树 -> 右子树 -> 根节点
    postOrder(root->left);
    postOrder(root->right);
    vec.push_back(root->val);
}
```

```c++
/* 后序遍历非递归方法 */
vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }

```

***

##### 此时我们用迭代法写出了二叉树的前后中序遍历，大家可以看出前序和中序是完全两种代码风格，并不像递归写法那样代码稍做调整，就可以实现前后中序。

##### 其实**针对三种遍历方式，使用迭代法是可以写出统一风格的代码！**

##### 每个代码前面都是相同的示意图，方便理解

#### 递归法前序遍历

```c++
 vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
```

##### root节点1进栈，此时栈非空，进入while循环，栈顶元素1为`node`，进入第一个`if`判断，1出栈，1存在右节点3,3入栈，1存在左节点2,2入栈，1再次进栈，NULL进栈，此时栈元素是NULL、1、2、3，栈顶元素是NULL，进入第二个if判断，栈顶元素NULL出栈，此时的node为1,1出栈，进数组。此时栈顶元素2为node，进入第一个`if`判断，2出栈，2的右节点5进栈，2的左节点4进栈，2再次进栈，NULL进栈，此时栈内元素是NULL、2、4、5。由于栈顶元素是NULL，进入第二个`if`判断，栈顶元素NULL出栈此时的栈顶元素是2,2出栈，存入数组，此时4成为栈顶元素，又进入循环……

##### 不难看出，每次进入while循环先让栈顶元素出栈，然后分别以右左中的顺序入栈，再让NULL入栈，使第二次while循环进入第二个if判断，这样就能让中间节点优先出栈进入数组，从而进行前序遍历

#### 递归法中序遍历

```c++
vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right);  // 添加右节点（空节点不入栈）

                st.push(node);                          // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
```

##### 1作为中间节点先入栈，栈不为空，1为栈顶，进入第一个`if`判断，1出栈，1的右节点3入栈，1入栈，NULL入栈，1的左节点2入栈；此时栈内元素是2、NULL、1、3,；再次进入第一个`if`判断，2出栈，2的右节点5入栈，2入栈，NULL入栈，2的左节点4入栈；此时栈内元素是4、NULL、2、5、NULL、1、3；4是栈顶，4出栈，4不存在右节点、4入栈、NULL、入栈、4不存在左节点；此时站内元素是NULL、4、NULL、2、5、NULL、1、3；进入第二个`if`判断，NULL出栈，4是栈顶元素，4出栈，4存入数组；此时NULL是栈顶元素，进入第二个`if`循环，NULL出栈，2为栈顶，2出栈，2存入数组；此时栈内元素是5、NULL、1、3；5是栈顶，进入第一个`if`判断，5出栈，5不存在右节点，5再次进栈，NULL进栈，5不存在左节点；此时栈内元素是NULL、5、NULL、1、3；NULL是栈顶元素，进入第二个`if`判断，NULL出栈，5作为栈顶元素，5出栈，5进数组；此时数组元素是4、2、5；此时栈内元素是NULL、1、3；NULL是栈顶元素，进入第二个`if`判断，NULL出栈，1是栈顶，1出栈，1进数组……

#### 递归法后序遍历

```c++
vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);

                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                result.push_back(node->val);
            }
        }
        return result;
    }
```

##### 理解了前序遍历，理解中序遍历和后序遍历就不难了，无非就是调换顺序，由于栈是后进先出，所以对于中序左中右，遍历顺序改为右中左；后序遍历是左右中，遍历顺序是中右左

### 广度优先搜索(BFS)

##### 一层一层去遍历，或者是一圈一圈去遍历

```c++
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
```

```c++
·    //递归法
	void order(TreeNode* cur, vector<vector<int>>& result, int depth)
    {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
```

# 第八天

##### 555~，写的笔记不见了，只能重新补上

## 二叉树：1.二叉树的层序遍历II

#### 对应力扣 [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

##### 题目要求从低向上层序遍历，按层序遍历的规则这是不可能的，我们只需要将最后的数组翻转一下就行了

```c++
vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> result;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            vector<int> vec;
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        reverse(result.begin(),result.end());
        return result;
    }
```

## 二叉树：2.二叉树的右视图

#### 对应力扣 [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

##### 这道题要求从右边看树，其实这也对应的是每一层最后一个节点，我们只需要让`i==size-1`的时候将当前节点的值存入数组就可以了

```c++
vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
       vector<int>result;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                if(i==(size-1)) result.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return result;
    }
```

## 二叉树：3.二叉树的层平均值

#### 对应力扣 [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

##### 这道题其实就是在遍历每一层的时候将节点的值加起来，然后除以节点个数

```c++
vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        vector<double> result;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            double sum=0;
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                sum+=node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
           result.push_back(sum/size);
        }
        return result;
    }
```

## 二叉树：4.在每个树形中找最大值

#### 对应力扣 [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

##### 本题其实就是用一个变量`maxNode`去接收最大值，注意，`maxNode`应该赋值为`INT_MIN`，以免所有的数都很小而导致`maxNode`无法更新

```c++
vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> result;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            TreeNode* maxNode=new TreeNode(INT_MIN);
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                maxNode=node->val>maxNode->val?node:maxNode;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(maxNode->val);
        }
        return result;
    }

```

## 二叉树：5.二叉树的最大深度

#### 对应力扣 [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

##### 每经过一层for循环代表遍历完了一层，depth++

```c++
int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        int depth=0;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth++;
        }
        return depth;
    }
```

## 二叉树：6.二叉树的最小深度

#### 对应力扣 [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

##### 做一个判断，如果当前节点既没有左节点也没有右节点，那他就是最小深度

```c++
int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        int depth=0;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            depth++;
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
                if(!node->left && !node->right) return depth;
            }
        }
        return depth;
    }
```

## 二叉树：7.翻转二叉树

#### 对应力扣 [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

##### 思路很简单，对于一个节点而言，交换他的左右节点即可

```c++
TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty()){
            int size=que.size();
            for(int i=0;i<size;i++){
                TreeNode* node=que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);

                swap(node->left,node->right);
            }
        }
        return root;
    }
```

## 二叉树：8.对称二叉树

#### 对应力扣 [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

##### 其实就是简单的层序遍历，碰到没有左右节点，用一个数字占位就可以了，到时候检查每一层的数组是否是回文数组

```c++
bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != nullptr) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node != nullptr) {
                    vec.push_back(node->val);
                    que.push(node->left);
                    que.push(node->right);
                } else {
                    vec.push_back(INT_MIN); 
                }
            }
            int left = 0;
            int right = vec.size() - 1;
            while (left < right) {
            if (vec[left] != vec[right]) {
                return false;
            }
            left++;
            right--;
        }
            }
        return true;
    }
```

