# 第六天

## 基础复习

##### 哈希表是它通过建立键 `key` 与值 `value` 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 `key`，则可以在 𝑂(1) 时间内获取对应的值 `value`。

##### 常用的哈希表有set和map

| **集合** | 底层实现 | **是否有序** | **数值是否可以重复** | **能否更改数值** | **查询效率** | **增删效率** |
|  ----  | ----   | ----   | ----   | ----   | ----   | ----   |
| std::set           | 红黑树   | 有序         | 否                   | 否               | O(log n)     | O(log n) |
| std::multiset      | 红黑树   | 有序         | 是                   | 否               | O(log n)     | O(log n) |
| std::unordered_set | 哈希表   | 无序         | 否                   | 否               | O(1)         | O(1) |

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

#### 详细信息可见 <a href="https://www.hello-algo.com/chapter_hashing/hash_map/">"Hello 算法"</a>

## 哈希表：1.有效字母异位词

#### 对应力扣 <a href="https://leetcode.cn/problems/valid-anagram/description/">242.有效字母异位词</a>

##### 这道题并不复杂，不会哈希表用双层`for`循环也能解决；这里因为数据量比较少，只有26个英文字母，所以综合考虑效率我们可以使用数组作为哈希表，因为对于int数组而言只能存储整形数据，而字母有`ASCII`码，所以我们把每个字母-'a'，这样就可以分别得到各个字母的数组下标，从而统计字母个数；因为要比较两个字符串字母个数是否相等，我们可以遍历第二个字符串，遇到相同的字母哈希表对应字母的个数减一；最后我们只用检查新的哈希表所有字母个数是否为0就能知道两个字符串字母个数是否相等

```c++
bool isAnagram(string s, string t) {
    //使用数组做哈希表
    //一定要做初始化
    int hash[26]={0};
    for(char i : s){
        hash[i-'a']++;
    }
    for(char i : t){
        hash[i-'a']--;
    }
    for(int i=0;i<26;i++){
        //如果找到任一一个字母个数不为0直接返回false
        if(hash[i]!=0){
            return false;
        }
    }
    return true;
}
```

## 哈希表：2. 两个数组的交集

#### 对应力扣 <a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349.两个数组的交集</a>

##### 这里的数据量比较少，所以我们可以使用数组当做哈希表，但是因为上一道题使用过了数组，所以我们优先使用`unordered_set`，这里选择`unordered_set`的原因是元素不需要排序，这样可以减少时间复杂度

### （1）unordered_set

##### 我们定义一个result_set容器用于接收最后的结果数据，先把num1的元素导入num_set，这时nums1的数据已经完成去重，我们再遍历nums2的元素，并且使用find函数查找，如果num_set能找到与nums2相同的元素，就把这个元素放入result_set，由于函数最后要返回vector容器，我们需要将result_set的元素导入vector并返回

```c++
//使用unordered_set
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int>result_set;
    unordered_set<int>num_set(nums1.begin(),nums1.end());
    for(int i:nums2){
        if(num_set.find(i)!=num_set.end()){
            result_set.insert(i);
        }
    }
    return vector<int>(result_set.begin(),result_set.end());
}
```

### （2）数组

##### 这里因为元素量比较少，我们可以使用数组作为哈希表，他的速度肯定是要快于unordered_set

##### 我们将nums1的元素导入hash数组，并且把每个元素的出现次数设置为1，从而达到去重的效果；然后遍历nums2的元素，如果当前元素在hash数组中出现过，我们就将这些元素导入result_set，最后的操作与上面一样

```c++
vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
    unordered_set<int>result_set;
    int hash[1005]={0};
    for(int i:nums1){
        hash[i]=1;
    }
    for(int i:nums2){
        if(hash[i]==1){
            result_set.insert(i);
        }
    }
    return vector<int>(result_set.begin(),result_set.end());
}
```

### 总结

##### 本题既可以使用set，也可以使用数组，那么什么有什么区别呢？

##### 当数据量比较大或者数据跨度比较大的时候我们可以选择set或map，比如有1万个元素，或者只有3个元素，但是这三个元素分别是{1,2,10000}；其余情况，数据量小的时候我们可以使用数组，并且数组的速度是要快于set和map的。

# 第七天

## 哈希表：3.两数相加

#### 对应力扣 [1.两数之和](https://leetcode.cn/problems/two-sum/submissions/528153671/)

##### 本题是力扣的第一道题，单纯从解题方法上并不困难，一般人使用双层for循环也可以解决；在这里使用哈希表解题

##### 我们定义一个哈希表unordered_map，为什么不使用set或map的原因是我们需要存储已经遍历过的元素，只用map有键值对，value对应数组元素的值，key对应数组的下标；况且存储元素不需要排序，所以采用unordered_map

##### 本题的思路是便利nums的元素，比如第一个元素nums[0]=2,target=9，我们就要在哈希表中寻找是否存储过target-nums[0]，也就是7，如果哈希表中存在value为7的对，我们就分别返回他们的下标，如果没有，我们就讲当前元素也就是nums[0]存进哈希表，继续遍历nums下一个元素

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int,int> map;
    for(int i=0;i<nums.size();i++){
        int s=target-nums[i];
        auto iter=map.find(s);
        if(iter!=map.end())
            return {iter->second,i};
        map.insert(pair<int,int>(nums[i],i));
    }
    return{};
}
```

## 哈希表：4.四数相加II

#### 对应力扣 [454.四数相加II](https://leetcode.cn/problems/4sum-ii/)

##### 本题虽然真的可以用四层for循环，但是在力扣中会超时，所以我们不得不思考另一种方法

##### 四个数组，从每个数组中各取一个元素，让这四个元素相加等于0，我们可以把四个数组分成两组，一组两个数组进行两层for循环，得到所有的相加之和，并把他们存储在`hash`表中，`key`对应两数之和，value对应个数，这时我们再将整合过得hash表拿在第二组两组数组nums3，nums4中进行双层for循环，并寻找在hash表中是否存在0-num3-num4,（因为四个数相加等于0，分成两组，如果一组的和为num，那为了符合条件，另一组应该是0-num），如果存在，让计数器count+=hash表对应的`value`。为什么要分成两组，一组两个数组，不能一组1个数组，另一组3个数组吗？分成两组两个数组的时间复杂的都是O(n^2)，相加还是O(n^2)，如果分成1个数组和3个数组，那时间复杂度是O(n)+O(n^3)=O(n^3)是大于O(n^2)

```c++
    unordered_map<int,int> add(vector<int>& nums1,vector<int>& nums2){
        unordered_map<int,int>mp;
        for(int num1:nums1){
            for(int num2:nums2){
                mp[num1+num2]++;
            }
        } 
        return mp;
    }

    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int> mp=add(nums1,nums2);
        int count=0;
        for(int num3:nums3){
            for(int num4:nums4){
                if(mp.find(0-num3-num4)!=mp.end()){
                    count+=mp[0-num3-num4];
                }
            }
        }
        return count;
    }
```

# 第八天

## 哈希表：5.快乐数

#### 对应力扣 [202. 快乐数](https://leetcode.cn/problems/happy-number/)

##### 本题我们定义两个函数，`getSum`用于拆分数字，并计算他对应的快乐数，题目说这个计算快乐数的过程可能是无线循环的，因此我们也使用while无限循环，将已经计算过的快乐数存入`unordered_set`容器，目的是以后算出新的快乐数去容器里找以前是否出现过，如果出现了就表示这个while循环会一直进行下去，此时就可以返回false了，如果找到了相加等于1的数字，就可以返回true了

```c++
int getSum(int  n){
        int sum = 0;
        while(n){
            sum += pow(n % 10, 2);
            n /= 10;
        }
        return sum;
    }


    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = getSum(n);
            if(sum == 1) return true;
            if(set.find(sum) != set.end()) return false;
            else set.insert(sum);
            n = sum;
        }
    }
```

## 哈希表：6.三数之和

#### 对应力扣 [15. 三数之和](https://leetcode.cn/problems/3sum/)

#### 双指针法

##### 本题推荐使用双指针法，因为这道题最大的难点在于去重，哈希表要进行去重和剪枝的操作很麻烦，并且使用了双层for循环，时间复杂度也不低，不太推荐使用

##### 我们在最外层使用for循环，同时定义两个`指针`left和right，left的起始位置是`i+1`,right的起始位置是`nums.size()-1`；我们的目的是求三个数的和是否等于0，这道题使用双指针的前提是排序，如果数组的第一个值就大于0，我们可以直接返回空数组，因为连数组最小的值都大于0，那不可能找到三数之和等于0的数字；

##### 第一次去重。如果有多个相同的数值这个时候其实只需要计算一次，比如`-1,-1,0,1`，答案是`[-1,0,1]`但是按照我们的想法i是会去遍历整个数组的，那两个-1他都会去计算一次，这是没有必要的，那这时关于去重顺序就有将就了，是`if(nums[i] == nums[i + 1])`还是`nums[i] == nums[i - 1]`?想象一种情况`-1,-1,2`,如果我们使用第一种方法，那么我们会直接跳过第一个-1，这是不对的，我们就损失了一种结果，所以应该采取第二种方式，当然前提是i需要大于0

##### 如果`nums[i] + nums[left] + nums[right]`之和大于0，我们应该让right指针进行`--`操作（前提是数组经过排序）,如果三数之和小于0，我们让left进行`++`操作，如果发现三数之和等于0，我们就找到了那三个数；

##### 还没完，比如`-2,-1,0,2,3`,此时`i = -2`,`left = -1`,`right = 3`，这是满足条件的，但是这并不代表在双指针内的数字不满足，`-2,0,2`这三个数字也是满足条件的，所以双指针内的数字我们还需要进行遍历，在`right>left`的前提下，如果`nums[right] == nums[right - 1]`我们就需要去重，让`right--`不然就会产生两个相同的结果,left也是相同的意思，如果`nums[left] == nums[left + 1]`就令`left++`,当然我们找到三个数并把他们存入数组后也需要手动让`right--;left++;`不然指针根本没动，无法进行接下来的判断。

```c++
vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());

        for(int i = 0; i < nums.size(); i++) {
          	// 如果数组的第一个值就大于0，我们可以直接返回空数组
            if(nums[i] > 0) return result;
            if(i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right) {
                if(nums[i] + nums[left] + nums[right] > 0) right--;
                else if(nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while(right > left && nums[right] == nums[right - 1]) right--;
                    while(right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return result;
    }
```

## 哈希表：7.赎金信

#### 对应力扣 [383. 赎金信](https://leetcode.cn/problems/ransom-note/)

##### 本题整体上比较简单，我们使用哈希表，先将`magazine`的所有值存入哈希表，然后遍历`ransomNote`的时候一一从哈希表中删除，如果哈希表中对应字母的个数小于0个就表示要么哈希表中没有那个字母，要么相应的字母数量过少，也无法满足条件

##### 这里我们推荐使用数组作为哈希表，因为题目确定了都是小写字母，所以数量可控，用数组会比map快不少

```c++
bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        if(ransomNote.size() > magazine.size()) return false;
        for(int i = 0; i < magazine.size(); i++){
            record[magazine[i] - 'a']++;
        }

        for(int i =0; i < ransomNote.size(); i++){
            record[ransomNote[i] - 'a']--;

            if(record[ransomNote[i] - 'a'] < 0) return false;
        }
        return true; 
    }
```



