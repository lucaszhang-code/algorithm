# å›¾

##### å›¾ï¼ˆgraphï¼‰æ˜¯ä¸€ç§éçº¿æ€§æ•°æ®ç»“æ„ï¼Œç”±é¡¶ç‚¹ï¼ˆvertexï¼‰å’Œè¾¹ï¼ˆedgeï¼‰ç»„æˆã€‚æˆ‘ä»¬å¯ä»¥å°†å›¾ ğº æŠ½è±¡åœ°è¡¨ç¤ºä¸ºä¸€ç»„é¡¶ç‚¹ ğ‘‰ å’Œä¸€ç»„è¾¹ ğ¸ çš„é›†åˆã€‚

![](https://www.hello-algo.com/chapter_graph/graph.assets/linkedlist_tree_graph.png)

##### å›¾æ•°æ®ç»“æ„åŒ…å«ä»¥ä¸‹å¸¸ç”¨æœ¯è¯­ã€‚

- é‚»æ¥ï¼ˆadjacencyï¼‰ï¼šå½“ä¸¤é¡¶ç‚¹ä¹‹é—´å­˜åœ¨è¾¹ç›¸è¿æ—¶ï¼Œç§°è¿™ä¸¤é¡¶ç‚¹â€œé‚»æ¥â€ã€‚åœ¨ä¸‹æ–¹å›¾ä¸­ï¼Œé¡¶ç‚¹ 1 çš„é‚»æ¥é¡¶ç‚¹ä¸ºé¡¶ç‚¹ 2ã€3ã€5ã€‚
- è·¯å¾„ï¼ˆpathï¼‰ï¼šä»é¡¶ç‚¹ A åˆ°é¡¶ç‚¹ B ç»è¿‡çš„è¾¹æ„æˆçš„åºåˆ—è¢«ç§°ä¸ºä» A åˆ° B çš„â€œè·¯å¾„â€ã€‚åœ¨ä¸‹æ–¹å›¾ä¸­ï¼Œè¾¹åºåˆ— 1-5-2-4 æ˜¯é¡¶ç‚¹ 1 åˆ°é¡¶ç‚¹ 4 çš„ä¸€æ¡è·¯å¾„ã€‚
- åº¦ï¼ˆdegreeï¼‰ï¼šä¸€ä¸ªé¡¶ç‚¹æ‹¥æœ‰çš„è¾¹æ•°ã€‚å¯¹äºæœ‰å‘å›¾ï¼Œå…¥åº¦ï¼ˆin-degreeï¼‰è¡¨ç¤ºæœ‰å¤šå°‘æ¡è¾¹æŒ‡å‘è¯¥é¡¶ç‚¹ï¼Œå‡ºåº¦ï¼ˆout-degreeï¼‰è¡¨ç¤ºæœ‰å¤šå°‘æ¡è¾¹ä»è¯¥é¡¶ç‚¹æŒ‡å‡ºã€‚

![](https://www.hello-algo.com/chapter_graph/graph.assets/weighted_graph.png)

### å›¾çš„è¡¨ç¤º

#### 1.  é‚»æ¥çŸ©é˜µ

è®¾å›¾çš„é¡¶ç‚¹æ•°é‡ä¸º ğ‘› ï¼Œé‚»æ¥çŸ©é˜µï¼ˆadjacency matrixï¼‰ä½¿ç”¨ä¸€ä¸ª ğ‘›Ã—ğ‘› å¤§å°çš„çŸ©é˜µæ¥è¡¨ç¤ºå›¾ï¼Œæ¯ä¸€è¡Œï¼ˆåˆ—ï¼‰ä»£è¡¨ä¸€ä¸ªé¡¶ç‚¹ï¼ŒçŸ©é˜µå…ƒç´ ä»£è¡¨è¾¹ï¼Œç”¨ 1 æˆ– 0 è¡¨ç¤ºä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ˜¯å¦å­˜åœ¨è¾¹ã€‚

å¦‚å›¾ä¸‹å›¾æ‰€ç¤ºï¼Œè®¾é‚»æ¥çŸ©é˜µä¸º ğ‘€ã€é¡¶ç‚¹åˆ—è¡¨ä¸º ğ‘‰ ï¼Œé‚£ä¹ˆçŸ©é˜µå…ƒç´  ğ‘€[ğ‘–,ğ‘—]=1 è¡¨ç¤ºé¡¶ç‚¹ ğ‘‰[ğ‘–] åˆ°é¡¶ç‚¹ ğ‘‰[ğ‘—] ä¹‹é—´å­˜åœ¨è¾¹ï¼Œåä¹‹ ğ‘€[ğ‘–,ğ‘—]=0 è¡¨ç¤ºä¸¤é¡¶ç‚¹ä¹‹é—´æ— è¾¹ã€‚

![](https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png)

##### æ³¨æ„ï¼šå°†é‚»æ¥çŸ©é˜µçš„å…ƒç´ ä» 1 å’Œ 0 æ›¿æ¢ä¸ºæƒé‡ï¼Œåˆ™å¯è¡¨ç¤ºæœ‰æƒå›¾ã€‚

### 2.é‚»æ¥è¡¨

é‚»æ¥è¡¨ï¼ˆadjacency listï¼‰ä½¿ç”¨ ğ‘› ä¸ªé“¾è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œé“¾è¡¨èŠ‚ç‚¹è¡¨ç¤ºé¡¶ç‚¹ã€‚ç¬¬ ğ‘– ä¸ªé“¾è¡¨å¯¹åº”é¡¶ç‚¹ ğ‘– ï¼Œå…¶ä¸­å­˜å‚¨äº†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹ï¼ˆä¸è¯¥é¡¶ç‚¹ç›¸è¿çš„é¡¶ç‚¹ï¼‰ã€‚ä¸‹æ–¹å›¾å±•ç¤ºäº†ä¸€ä¸ªä½¿ç”¨é‚»æ¥è¡¨å­˜å‚¨çš„å›¾çš„ç¤ºä¾‹ã€‚

![](https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png)

## é‚»æ¥çŸ©é˜µçš„æ„é€ 

```c++
class Matrix {
private:
    vector<int>vertices = {0, 1, 2, 3};		// é¡¶ç‚¹
    int size = vertices.size();				// é¡¶ç‚¹çš„ä¸ªæ•°
    vector<vector<int>> finalMatrix;		// é‚»æ¥çŸ©é˜µ
public:
    // æœ‰å‚æ„é€ ï¼Œç”¨æˆ·ä¼ å…¥ç›¸è¿æ¥è¾¹çš„äºŒç»´çŸ©é˜µï¼›åˆå§‹åŒ–finalMatrixæˆå‘˜å˜é‡ï¼Œå½¢æˆä¸€ä¸ªsize*sizeçš„äºŒç»´çŸ©é˜µï¼Œå¹¶å°†æ‰€æœ‰å€¼èµ‹å€¼ä¸º0
    Matrix(vector<vector<int>> matrix) : finalMatrix(size, vector<int>(size, 0)){
        for(auto &vec : matrix){
            finalMatrix[vec[0]][vec[1]] = 1;
            finalMatrix[vec[1]][vec[0]] = 1;
        }
    }
    
    // æ·»åŠ é¡¶ç‚¹
    void addVertex(int x){
        vertices.push_back(x);
        size++;
        // finalMatrixæ·»åŠ ä¸€ä¸ªé•¿åº¦ä¸ºsizeçš„ä¸€ç»´æ•°ç»„ï¼Œå¹¶å°†è¿™ä¸ªæ•°ç»„æ‰€æœ‰å…ƒç´ åˆå§‹åŒ–æˆ0
        finalMatrix.emplace_back(size, 0);
        // ç»™æ¯ä¸ªä¸€ç»´æ•°ç»„çš„æœ«å°¾æ·»åŠ å…ƒç´ 0
        for(auto &vec : finalMatrix){
            vec.push_back(0);
        }
    }
    
    // åˆ é™¤é¡¶ç‚¹
    void deleteVertex(int x){
        // æ ¹æ®è¿­ä»£å™¨åˆ é™¤ç¬¬xä¸ªé¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯xè¡Œ
        vertices.erase(vertices.begin()+x);
        size--;
        finalMatrix.erase(finalMatrix.begin()+x);
        for(auto &vec : finalMatrix){
            vec.erase(vec.begin()+x);
        }
    }
    
    // æ·»åŠ è¾¹
    void addEdge(int x, int y){
        finalMatrix[x][y] = 1;
        finalMatrix[y][x] = 1;
    }

    // åˆ é™¤è¾¹
    void deleteEdge(int x, int y){
        finalMatrix[x][y] = 0;
        finalMatrix[y][x] = 0;
    }

    void printMatrix(){
        for(const auto& vec : finalMatrix){
            for(int num : vec){
                cout<<num<<" ";
            }
            cout<<endl;
        }
    }
};
```

##### ç¤ºä¾‹`main`å‡½æ•°

```c++
int main(){
    vector<vector<int>> matrix = {{0,1},{1,1},{1,3},{2,3}};

    Matrix m(matrix);
    m.addEdge(2,2);
    m.deleteEdge(0,1);
    m.printMatrix();

    return 0;
}
```

##### è¾“å‡ºç»“æœ

```c++
0 0 0 0
0 1 0 1
0 0 1 1
0 1 1 0
```



## é‚»æ¥è¡¨çš„å®ç°

```c++
// Vertexæ˜¯å›¾çš„é¡¶ç‚¹ï¼Œå®ƒåŒ…å«å€¼å’Œç›¸åº”çš„å‡½æ•°
struct Vertex {
    int val;
    Vertex(int value) : val(value) {}
};

/* åŸºäºé‚»æ¥è¡¨å®ç°çš„æ— å‘å›¾ç±» */
class GraphAdjList {
public:
    /**
    * ä½¿ç”¨æ— åºå“ˆå¸Œè¡¨å»é‡
    * é‚»æ¥è¡¨ï¼Œkeyï¼šé¡¶ç‚¹ï¼Œvalueï¼šè¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    * ç®€å•æ¥è¯´æ¯”å¦‚é¡¶ç‚¹1å’Œé¡¶ç‚¹3ã€4ç›¸è¿æ¥ï¼Œé‚£ä¹ˆå“ˆå¸Œè¡¨çš„key:1,value:[3,4]
    */
    unordered_map<Vertex *, vector<Vertex *>> adjList;

    /**
    * åœ¨ vector ä¸­åˆ é™¤æŒ‡å®šèŠ‚ç‚¹
    * è¿™æ˜¯ä¸€ä¸ªå·¥å…·å‡½æ•°ï¼Œä¸»è¦ç”¨äºåˆ é™¤ä¸€ä¸ªæ•°ç»„ä¸­çš„æŒ‡å®šå…ƒç´ 
    * removeå‡½æ•°ä¼ å…¥é‚»æ¥æ•°ç»„å’ŒæŒ‡å®šè¦åˆ é™¤çš„èŠ‚ç‚¹
    * éå†æ•°ç»„ï¼Œæ‰¾åˆ°å¯¹åº”çš„å…ƒç´ å¹¶åˆ é™¤
    */
    void remove(vector<Vertex *> &vec, Vertex *vet) {
        for (int i = 0; i < vec.size(); i++) {
            if (vec[i] == vet) {
                vec.erase(vec.begin() + i);
                break;
            }
        }
    }

    /* æ„é€ æ–¹æ³• */
    GraphAdjList(const vector<vector<Vertex *>> &edges) {
        // æ·»åŠ æ‰€æœ‰é¡¶ç‚¹å’Œè¾¹
        for (const vector<Vertex *> &edge : edges) {
            addVertex(edge[0]);
            addVertex(edge[1]);
            addEdge(edge[0], edge[1]);
        }
    }

    /* è·å–é¡¶ç‚¹æ•°é‡ */
    int size() {
        return adjList.size();
    }

    /** 
    * æ·»åŠ è¾¹ 
    * addEdgeå‡½æ•°ä¼ å…¥ä¸¤ä¸ªé¡¶ç‚¹
    * é€šè¿‡countå‡½æ•°æ£€æŸ¥ä¼ å…¥çš„ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¦å­˜åœ¨äºadListï¼Œæˆ–è€…ä¸¤ä¸ªé¡¶ç‚¹æ˜¯å¦ç›¸åŒ
    * åˆ†åˆ«å°†é¡¶ç‚¹ä¼ å…¥adListè¿™ä¸ªæ— åºå“ˆå¸Œè¡¨
    * æ¯”å¦‚é¡¶ç‚¹1å’Œé¡¶ç‚¹2ç›¸è¿æ¥ï¼Œé‚£ä¹ˆåœ¨å“ˆå¸Œè¡¨ä¸­kï¼š1 - vï¼š2ï¼›åŒæ—¶kï¼š2 - vï¼š1
    */
    void addEdge(Vertex *vet1, Vertex *vet2) {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("ä¸å­˜åœ¨é¡¶ç‚¹");
        // æ·»åŠ è¾¹ vet1 - vet2
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /** 
    * åˆ é™¤è¾¹ 
    * è°ƒç”¨å·¥å…·å‡½æ•°ï¼Œåˆ é™¤ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´çš„è¾¹
    */
    void removeEdge(Vertex *vet1, Vertex *vet2) {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("ä¸å­˜åœ¨é¡¶ç‚¹");
        // åˆ é™¤è¾¹ vet1 - vet2
        remove(adjList[vet1], vet2);
        remove(adjList[vet2], vet1);
    }

    /** 
    * æ·»åŠ é¡¶ç‚¹ 
    * åˆ¤æ–­è¦æ·»åŠ çš„æ–°é¡¶ç‚¹æ˜¯å¦å­˜åœ¨äºadListé‡Œï¼ˆæ–°æ·»åŠ çš„é¡¶ç‚¹ç†è®ºä¸Šä¸åº”è¯¥å­˜åœ¨å…¶ä¸­ï¼‰
    * åœ¨adListä¸­æ·»åŠ keyï¼švetï¼Œvalueï¼švector<Vertex *>()
    */
    void addVertex(Vertex *vet) {
        if (adjList.count(vet))
            return;
        // åœ¨é‚»æ¥è¡¨ä¸­æ·»åŠ ä¸€ä¸ªæ–°é“¾è¡¨
        adjList[vet] = vector<Vertex *>();
    }

    /** 
    * åˆ é™¤é¡¶ç‚¹ 
    * åˆ é™¤å­˜åœ¨äºadListä¸­çš„é¡¶ç‚¹
    * ä½¿ç”¨eraseå‡½æ•°åˆ é™¤å“ˆå¸Œè¡¨ä¸­key:vet
    */
    void removeVertex(Vertex *vet) {
        if (!adjList.count(vet))
            throw invalid_argument("ä¸å­˜åœ¨é¡¶ç‚¹");
        // åœ¨é‚»æ¥è¡¨ä¸­åˆ é™¤é¡¶ç‚¹ vet å¯¹åº”çš„é“¾è¡¨
        adjList.erase(vet);
        // éå†å…¶ä»–é¡¶ç‚¹çš„é“¾è¡¨ï¼Œåˆ é™¤æ‰€æœ‰åŒ…å« vet çš„è¾¹
        for (auto &adj : adjList) {
            remove(adj.second, vet);
        }
    }

    /** 
    * å°†é¡¶ç‚¹çš„æŒ‡é’ˆåˆ—è¡¨è½¬æ¢ä¸ºé¡¶ç‚¹çš„å€¼åˆ—è¡¨ 
    * ä¼ å…¥adListçš„valueï¼Œéå†valueæ•°ç»„ï¼Œå¾—åˆ°æ•°ç»„ä¸­æ‰€æœ‰é¡¶ç‚¹çš„valå€¼ï¼ŒæŠŠä»–èµ‹å€¼ç»™valsè¿™ä¸ªæ–°å‡½æ•°
    */
    vector<int> vetsToVals(const vector<Vertex *> &vec) const {
        vector<int> vals;
        for (const Vertex *vet : vec) {
            vals.push_back(vet->val);
        }
        // å°†æ•°ç»„è¿›è¡Œæ’åº
        sort(vals.begin(), vals.end());
        return vals;
    }

    /* æ‰“å° vector<int> */
    void printVector(const vector<int> &vec) const {
        for (int val : vec) {
            cout << val << " ";
        }
        cout << endl;
    }

    /** 
    * æ‰“å°é‚»æ¥è¡¨ 
    * éå†adListå“ˆå¸Œè¡¨ï¼Œä»–çš„adj.firstæ˜¯keyï¼›adj.secondæ˜¯value
    * ç›´æ¥è¾“å‡ºkey->valçš„å€¼ï¼Œå°†valueï¼ˆæ•°ç»„ï¼‰èµ‹å€¼ç»™vecï¼Œä½¿ç”¨vetsToValså‡½æ•°å–å‡ºæ•°ç»„é‡Œé¢æ¯ä¸ªé¡¶ç‚¹çš„å€¼ï¼Œå¹¶ä¸”æ‰“å°å‡ºæ¥
    */
    void print() const {
        cout << "é‚»æ¥è¡¨ =" << endl;
        for (const auto &adj : adjList) {
            Vertex *key = adj.first;
            vector<Vertex *> vec = adj.second;
            cout << key->val << ": ";
            printVector(vetsToVals(vec));
        }
    }
};
```

##### ç¤ºä¾‹`main`å‡½æ•°

```c++
int main() {
    Vertex *v0 = new Vertex(0);
    Vertex *v1 = new Vertex(1);
    Vertex *v2 = new Vertex(2);
    Vertex *v3 = new Vertex(3);

    vector<vector<Vertex *>> edges = {{v0, v1}, {v1, v2}, {v2, v3}, {v3, v0}, {v0, v2}};

    GraphAdjList graph(edges);
    graph.print();

    delete v0;
    delete v1;
    delete v2;
    delete v3;

    return 0;
}
```

##### è¾“å‡ºç»“æœ

```c++
é‚»æ¥è¡¨ =
3: 0 2
2: 0 1 3
1: 0 2
0: 1 2 3
```

## å›¾çš„éå†

### å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰

è¯¦ç»†ä¿¡æ¯å¯è§ https://www.hello-algo.com/chapter_graph/graph_traversal/#1ï¼Œè¿™é‡Œä¸åšè§£é‡Š

å¦‚æœä½ æ¸…æ¥šäºŒå‰æ ‘çš„BFSï¼Œé‚£è¿™ä¸ªå…¶å®å¤§åŒå°å¼‚

```c++
	/* å¹¿åº¦ä¼˜å…ˆéå† */
    /** 
    * ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œä»¥ä¾¿è·å–æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    * è¿™é‡Œä¼ å…¥çš„æ˜¯GraphAdjListç±»å’Œèµ·ç‚¹ä½ç½®ï¼Œåœ¨ä¹‹å‰æˆ‘ä»¬å·²ç»æ„é€ äº†è¿™ä¸ªç±»å’Œä»–çš„ç§æœ‰æˆå‘˜adList
    */
    vector<Vertex *> graphBFS(GraphAdjList &graph, Vertex *startVet) {
        // é¡¶ç‚¹éå†åºåˆ—
        vector<Vertex *> res;
        /** å“ˆå¸Œé›†åˆï¼Œç”¨äºè®°å½•å·²è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹
        * æœ€ä¸»è¦çš„ç›®çš„æ˜¯å»é‡å’Œå¿«é€ŸæŸ¥æ‰¾
        */
        unordered_set<Vertex *> visited = {startVet};
        // é˜Ÿåˆ—ç”¨äºå®ç° BFS
        queue<Vertex *> que;
        que.push(startVet);
        // ä»¥é¡¶ç‚¹ vet ä¸ºèµ·ç‚¹ï¼Œå¾ªç¯ç›´è‡³è®¿é—®å®Œæ‰€æœ‰é¡¶ç‚¹
        while (!que.empty()) {
            Vertex *vet = que.front();
            que.pop();          // é˜Ÿé¦–é¡¶ç‚¹å‡ºé˜Ÿ
            res.push_back(vet); // è®°å½•è®¿é—®é¡¶ç‚¹
            // éå†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
            for (auto adjVet : graph.adjList[vet]) {
                if (visited.count(adjVet))
                    continue;            // è·³è¿‡å·²è¢«è®¿é—®çš„é¡¶ç‚¹
                que.push(adjVet);        // åªå…¥é˜Ÿæœªè®¿é—®çš„é¡¶ç‚¹
                visited.emplace(adjVet); // æ ‡è®°è¯¥é¡¶ç‚¹å·²è¢«è®¿é—®
            }
        }
        // è¿”å›é¡¶ç‚¹éå†åºåˆ—
        return res;
    }
```

#### å®Œæ•´ä»£ç 

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>

using namespace std;

struct Vertex{
    int val;
    Vertex(int value):val(value){}
};

class GraphAdjList{
private:
    unordered_map<Vertex*, vector<Vertex*>> adjList;

public:
    GraphAdjList(vector<vector<Vertex*>> &edges){
        for(vector<Vertex*> vec : edges){
            addVertex(vec[0]);
            addVertex(vec[1]);
            addEdges(vec[0], vec[1]);
        }
    }

    void addVertex(Vertex* vets){
        if(adjList.count(vets)) return;
        adjList[vets] = vector<Vertex*>();
    }

    void addEdges(Vertex* vet1, Vertex* vet2){
        if(!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2) return;
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /* å¹¿åº¦ä¼˜å…ˆéå† */
    // ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œä»¥ä¾¿è·å–æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    vector<Vertex *> graphBFS(GraphAdjList &graph, Vertex *startVet) {
        // é¡¶ç‚¹éå†åºåˆ—
        vector<Vertex *> res;
        // å“ˆå¸Œé›†åˆï¼Œç”¨äºè®°å½•å·²è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹
        unordered_set<Vertex *> visited = {startVet};
        // é˜Ÿåˆ—ç”¨äºå®ç° BFS
        queue<Vertex *> que;
        que.push(startVet);
        // ä»¥é¡¶ç‚¹ vet ä¸ºèµ·ç‚¹ï¼Œå¾ªç¯ç›´è‡³è®¿é—®å®Œæ‰€æœ‰é¡¶ç‚¹
        while (!que.empty()) {
            Vertex *vet = que.front();
            que.pop();          // é˜Ÿé¦–é¡¶ç‚¹å‡ºé˜Ÿ
            res.push_back(vet); // è®°å½•è®¿é—®é¡¶ç‚¹
            // éå†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
            for (auto adjVet : graph.adjList[vet]) {
                if (visited.count(adjVet))
                    continue;            // è·³è¿‡å·²è¢«è®¿é—®çš„é¡¶ç‚¹
                que.push(adjVet);        // åªå…¥é˜Ÿæœªè®¿é—®çš„é¡¶ç‚¹
                visited.emplace(adjVet); // æ ‡è®°è¯¥é¡¶ç‚¹å·²è¢«è®¿é—®
            }
        }
        // è¿”å›é¡¶ç‚¹éå†åºåˆ—
        return res;
    }

    void printVec(vector<Vertex *> vec){
        for(Vertex *vet : vec){
            cout<< vet -> val <<"  ";
        }
        cout<<endl;
    }

};

int main(){

    Vertex* v0 = new Vertex(0);
    Vertex* v1 = new Vertex(1);
    Vertex* v2 = new Vertex(2);
    Vertex* v3 = new Vertex(3);
    Vertex* v4 = new Vertex(4);

    vector<vector<Vertex*>> edges = {{v0, v1}, {v0, v2}, {v1, v2}, {v2, v3}, {v3, v4}};
    GraphAdjList graph(edges);
    graph.printVec(graph.graphBFS(graph, v0));
    return 0;
}
```

#### è¿è¡Œç»“æœ

```c++
0  1  2  3  4
```

## æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰

è¯¦ç»†ä¿¡æ¯å¯è§ https://www.hello-algo.com/chapter_graph/graph_traversal/#932

```c++
/* æ·±åº¦ä¼˜å…ˆéå†è¾…åŠ©å‡½æ•° */
void dfs(GraphAdjList &graph, unordered_set<Vertex *> &visited, vector<Vertex *> &res, Vertex *vet) {
    res.push_back(vet);   // è®°å½•è®¿é—®é¡¶ç‚¹
    visited.emplace(vet); // æ ‡è®°è¯¥é¡¶ç‚¹å·²è¢«è®¿é—®
    // éå†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    for (Vertex *adjVet : graph.adjList[vet]) {
        if (visited.count(adjVet))
            continue; // è·³è¿‡å·²è¢«è®¿é—®çš„é¡¶ç‚¹
        // é€’å½’è®¿é—®é‚»æ¥é¡¶ç‚¹
        dfs(graph, visited, res, adjVet);
    }
}

/* æ·±åº¦ä¼˜å…ˆéå† */
// ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œä»¥ä¾¿è·å–æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
vector<Vertex *> graphDFS(GraphAdjList &graph, Vertex *startVet) {
    // é¡¶ç‚¹éå†åºåˆ—
    vector<Vertex *> res;
    // å“ˆå¸Œé›†åˆï¼Œç”¨äºè®°å½•å·²è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹
    unordered_set<Vertex *> visited;
    dfs(graph, visited, res, startVet);
    return res;
}
```

#### å®Œæ•´ä»£ç 

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>

using namespace std;

struct Vertex{
    int val;
    Vertex(int value):val(value){}
};

class GraphAdjList{
private:
    unordered_map<Vertex*, vector<Vertex*>> adjList;

public:
    GraphAdjList(vector<vector<Vertex*>> &edges){
        for(vector<Vertex*> vec : edges){
            addVertex(vec[0]);
            addVertex(vec[1]);
            addEdges(vec[0], vec[1]);
        }
    }

    void addVertex(Vertex* vets){
        if(adjList.count(vets)) return;
        adjList[vets] = vector<Vertex*>();
    }

    void addEdges(Vertex* vet1, Vertex* vet2){
        if(!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2) return;
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /* æ·±åº¦ä¼˜å…ˆéå†è¾…åŠ©å‡½æ•° */
    void dfs(GraphAdjList &graph, unordered_set<Vertex *> &visited, vector<Vertex *> &res, Vertex *vet) {
        res.push_back(vet);   // è®°å½•è®¿é—®é¡¶ç‚¹
        visited.emplace(vet); // æ ‡è®°è¯¥é¡¶ç‚¹å·²è¢«è®¿é—®
        // éå†è¯¥é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
        for (Vertex *adjVet : graph.adjList[vet]) {
            if (visited.count(adjVet))
                continue; // è·³è¿‡å·²è¢«è®¿é—®çš„é¡¶ç‚¹
            // é€’å½’è®¿é—®é‚»æ¥é¡¶ç‚¹
            dfs(graph, visited, res, adjVet);
        }
    }

    /* æ·±åº¦ä¼˜å…ˆéå† */
    // ä½¿ç”¨é‚»æ¥è¡¨æ¥è¡¨ç¤ºå›¾ï¼Œä»¥ä¾¿è·å–æŒ‡å®šé¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    vector<Vertex *> graphDFS(GraphAdjList &graph, Vertex *startVet) {
        // é¡¶ç‚¹éå†åºåˆ—
        vector<Vertex *> res;
        // å“ˆå¸Œé›†åˆï¼Œç”¨äºè®°å½•å·²è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹
        unordered_set<Vertex *> visited;
        dfs(graph, visited, res, startVet);
        return res;
    }

    void printVec(vector<Vertex *> vec){
        for(Vertex *vet : vec){
            cout<< vet -> val <<"  ";
        }
        cout<<endl;
    }

};

int main(){

    Vertex* v0 = new Vertex(0);
    Vertex* v1 = new Vertex(1);
    Vertex* v2 = new Vertex(2);
    Vertex* v3 = new Vertex(3);
    Vertex* v4 = new Vertex(4);
    Vertex* v5 = new Vertex(5);
    Vertex* v6 = new Vertex(6);

    vector<vector<Vertex*>> edges = {{v0, v1}, {v0, v3}, {v1, v2}, {v2, v5}, {v4, v5},{v5, v6}};

    GraphAdjList graph(edges);

    graph.printVec(graph.graphDFS(graph, v0));


    return 0;
}
```

#### è¿è¡Œç»“æœ

```c++
0  1  2  5  4  6  3
```



