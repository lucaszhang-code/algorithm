# 图

##### 图（graph）是一种非线性数据结构，由顶点（vertex）和边（edge）组成。我们可以将图 𝐺 抽象地表示为一组顶点 𝑉 和一组边 𝐸 的集合。

![](https://www.hello-algo.com/chapter_graph/graph.assets/linkedlist_tree_graph.png)

##### 图数据结构包含以下常用术语。

- 邻接（adjacency）：当两顶点之间存在边相连时，称这两顶点“邻接”。在下方图中，顶点 1 的邻接顶点为顶点 2、3、5。
- 路径（path）：从顶点 A 到顶点 B 经过的边构成的序列被称为从 A 到 B 的“路径”。在下方图中，边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径。
- 度（degree）：一个顶点拥有的边数。对于有向图，入度（in-degree）表示有多少条边指向该顶点，出度（out-degree）表示有多少条边从该顶点指出。

![](https://www.hello-algo.com/chapter_graph/graph.assets/weighted_graph.png)

### 图的表示

#### 1.  邻接矩阵

设图的顶点数量为 𝑛 ，邻接矩阵（adjacency matrix）使用一个 𝑛×𝑛 大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 1 或 0 表示两个顶点之间是否存在边。

如图下图所示，设邻接矩阵为 𝑀、顶点列表为 𝑉 ，那么矩阵元素 𝑀[𝑖,𝑗]=1 表示顶点 𝑉[𝑖] 到顶点 𝑉[𝑗] 之间存在边，反之 𝑀[𝑖,𝑗]=0 表示两顶点之间无边。

![](https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png)

##### 注意：将邻接矩阵的元素从 1 和 0 替换为权重，则可表示有权图。

### 2.邻接表

邻接表（adjacency list）使用 𝑛 个链表来表示图，链表节点表示顶点。第 𝑖 个链表对应顶点 𝑖 ，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。下方图展示了一个使用邻接表存储的图的示例。

![](https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png)

## 邻接矩阵的构造

```c++
class Matrix {
private:
    vector<int>vertices = {0, 1, 2, 3};		// 顶点
    int size = vertices.size();				// 顶点的个数
    vector<vector<int>> finalMatrix;		// 邻接矩阵
public:
    // 有参构造，用户传入相连接边的二维矩阵；初始化finalMatrix成员变量，形成一个size*size的二维矩阵，并将所有值赋值为0
    Matrix(vector<vector<int>> matrix) : finalMatrix(size, vector<int>(size, 0)){
        for(auto &vec : matrix){
            finalMatrix[vec[0]][vec[1]] = 1;
            finalMatrix[vec[1]][vec[0]] = 1;
        }
    }
    
    // 添加顶点
    void addVertex(int x){
        vertices.push_back(x);
        size++;
        // finalMatrix添加一个长度为size的一维数组，并将这个数组所有元素初始化成0
        finalMatrix.emplace_back(size, 0);
        // 给每个一维数组的末尾添加元素0
        for(auto &vec : finalMatrix){
            vec.push_back(0);
        }
    }
    
    // 删除顶点
    void deleteVertex(int x){
        // 根据迭代器删除第x个顶点，也就是x行
        vertices.erase(vertices.begin()+x);
        size--;
        finalMatrix.erase(finalMatrix.begin()+x);
        for(auto &vec : finalMatrix){
            vec.erase(vec.begin()+x);
        }
    }
    
    // 添加边
    void addEdge(int x, int y){
        finalMatrix[x][y] = 1;
        finalMatrix[y][x] = 1;
    }

    // 删除边
    void deleteEdge(int x, int y){
        finalMatrix[x][y] = 0;
        finalMatrix[y][x] = 0;
    }

    void printMatrix(){
        for(const auto& vec : finalMatrix){
            for(int num : vec){
                cout<<num<<" ";
            }
            cout<<endl;
        }
    }
};
```

##### 示例`main`函数

```c++
int main(){
    vector<vector<int>> matrix = {{0,1},{1,1},{1,3},{2,3}};

    Matrix m(matrix);
    m.addEdge(2,2);
    m.deleteEdge(0,1);
    m.printMatrix();

    return 0;
}
```

##### 输出结果

```c++
0 0 0 0
0 1 0 1
0 0 1 1
0 1 1 0
```



## 邻接表的实现

```c++
// Vertex是图的顶点，它包含值和相应的函数
struct Vertex {
    int val;
    Vertex(int value) : val(value) {}
};

/* 基于邻接表实现的无向图类 */
class GraphAdjList {
public:
    /**
    * 使用无序哈希表去重
    * 邻接表，key：顶点，value：该顶点的所有邻接顶点
    * 简单来说比如顶点1和顶点3、4相连接，那么哈希表的key:1,value:[3,4]
    */
    unordered_map<Vertex *, vector<Vertex *>> adjList;

    /**
    * 在 vector 中删除指定节点
    * 这是一个工具函数，主要用于删除一个数组中的指定元素
    * remove函数传入邻接数组和指定要删除的节点
    * 遍历数组，找到对应的元素并删除
    */
    void remove(vector<Vertex *> &vec, Vertex *vet) {
        for (int i = 0; i < vec.size(); i++) {
            if (vec[i] == vet) {
                vec.erase(vec.begin() + i);
                break;
            }
        }
    }

    /* 构造方法 */
    GraphAdjList(const vector<vector<Vertex *>> &edges) {
        // 添加所有顶点和边
        for (const vector<Vertex *> &edge : edges) {
            addVertex(edge[0]);
            addVertex(edge[1]);
            addEdge(edge[0], edge[1]);
        }
    }

    /* 获取顶点数量 */
    int size() {
        return adjList.size();
    }

    /** 
    * 添加边 
    * addEdge函数传入两个顶点
    * 通过count函数检查传入的两个顶点是否存在于adList，或者两个顶点是否相同
    * 分别将顶点传入adList这个无序哈希表
    * 比如顶点1和顶点2相连接，那么在哈希表中k：1 - v：2；同时k：2 - v：1
    */
    void addEdge(Vertex *vet1, Vertex *vet2) {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("不存在顶点");
        // 添加边 vet1 - vet2
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /** 
    * 删除边 
    * 调用工具函数，删除两个顶点之间的边
    */
    void removeEdge(Vertex *vet1, Vertex *vet2) {
        if (!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2)
            throw invalid_argument("不存在顶点");
        // 删除边 vet1 - vet2
        remove(adjList[vet1], vet2);
        remove(adjList[vet2], vet1);
    }

    /** 
    * 添加顶点 
    * 判断要添加的新顶点是否存在于adList里（新添加的顶点理论上不应该存在其中）
    * 在adList中添加key：vet，value：vector<Vertex *>()
    */
    void addVertex(Vertex *vet) {
        if (adjList.count(vet))
            return;
        // 在邻接表中添加一个新链表
        adjList[vet] = vector<Vertex *>();
    }

    /** 
    * 删除顶点 
    * 删除存在于adList中的顶点
    * 使用erase函数删除哈希表中key:vet
    */
    void removeVertex(Vertex *vet) {
        if (!adjList.count(vet))
            throw invalid_argument("不存在顶点");
        // 在邻接表中删除顶点 vet 对应的链表
        adjList.erase(vet);
        // 遍历其他顶点的链表，删除所有包含 vet 的边
        for (auto &adj : adjList) {
            remove(adj.second, vet);
        }
    }

    /** 
    * 将顶点的指针列表转换为顶点的值列表 
    * 传入adList的value，遍历value数组，得到数组中所有顶点的val值，把他赋值给vals这个新函数
    */
    vector<int> vetsToVals(const vector<Vertex *> &vec) const {
        vector<int> vals;
        for (const Vertex *vet : vec) {
            vals.push_back(vet->val);
        }
        // 将数组进行排序
        sort(vals.begin(), vals.end());
        return vals;
    }

    /* 打印 vector<int> */
    void printVector(const vector<int> &vec) const {
        for (int val : vec) {
            cout << val << " ";
        }
        cout << endl;
    }

    /** 
    * 打印邻接表 
    * 遍历adList哈希表，他的adj.first是key；adj.second是value
    * 直接输出key->val的值，将value（数组）赋值给vec，使用vetsToVals函数取出数组里面每个顶点的值，并且打印出来
    */
    void print() const {
        cout << "邻接表 =" << endl;
        for (const auto &adj : adjList) {
            Vertex *key = adj.first;
            vector<Vertex *> vec = adj.second;
            cout << key->val << ": ";
            printVector(vetsToVals(vec));
        }
    }
};
```

##### 示例`main`函数

```c++
int main() {
    Vertex *v0 = new Vertex(0);
    Vertex *v1 = new Vertex(1);
    Vertex *v2 = new Vertex(2);
    Vertex *v3 = new Vertex(3);

    vector<vector<Vertex *>> edges = {{v0, v1}, {v1, v2}, {v2, v3}, {v3, v0}, {v0, v2}};

    GraphAdjList graph(edges);
    graph.print();

    delete v0;
    delete v1;
    delete v2;
    delete v3;

    return 0;
}
```

##### 输出结果

```c++
邻接表 =
3: 0 2
2: 0 1 3
1: 0 2
0: 1 2 3
```

## 图的遍历

### 广度优先遍历（BFS）

详细信息可见 https://www.hello-algo.com/chapter_graph/graph_traversal/#1，这里不做解释

如果你清楚二叉树的BFS，那这个其实大同小异

```c++
	/* 广度优先遍历 */
    /** 
    * 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
    * 这里传入的是GraphAdjList类和起点位置，在之前我们已经构造了这个类和他的私有成员adList
    */
    vector<Vertex *> graphBFS(GraphAdjList &graph, Vertex *startVet) {
        // 顶点遍历序列
        vector<Vertex *> res;
        /** 哈希集合，用于记录已被访问过的顶点
        * 最主要的目的是去重和快速查找
        */
        unordered_set<Vertex *> visited = {startVet};
        // 队列用于实现 BFS
        queue<Vertex *> que;
        que.push(startVet);
        // 以顶点 vet 为起点，循环直至访问完所有顶点
        while (!que.empty()) {
            Vertex *vet = que.front();
            que.pop();          // 队首顶点出队
            res.push_back(vet); // 记录访问顶点
            // 遍历该顶点的所有邻接顶点
            for (auto adjVet : graph.adjList[vet]) {
                if (visited.count(adjVet))
                    continue;            // 跳过已被访问的顶点
                que.push(adjVet);        // 只入队未访问的顶点
                visited.emplace(adjVet); // 标记该顶点已被访问
            }
        }
        // 返回顶点遍历序列
        return res;
    }
```

#### 完整代码

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>

using namespace std;

struct Vertex{
    int val;
    Vertex(int value):val(value){}
};

class GraphAdjList{
private:
    unordered_map<Vertex*, vector<Vertex*>> adjList;

public:
    GraphAdjList(vector<vector<Vertex*>> &edges){
        for(vector<Vertex*> vec : edges){
            addVertex(vec[0]);
            addVertex(vec[1]);
            addEdges(vec[0], vec[1]);
        }
    }

    void addVertex(Vertex* vets){
        if(adjList.count(vets)) return;
        adjList[vets] = vector<Vertex*>();
    }

    void addEdges(Vertex* vet1, Vertex* vet2){
        if(!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2) return;
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /* 广度优先遍历 */
    // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
    vector<Vertex *> graphBFS(GraphAdjList &graph, Vertex *startVet) {
        // 顶点遍历序列
        vector<Vertex *> res;
        // 哈希集合，用于记录已被访问过的顶点
        unordered_set<Vertex *> visited = {startVet};
        // 队列用于实现 BFS
        queue<Vertex *> que;
        que.push(startVet);
        // 以顶点 vet 为起点，循环直至访问完所有顶点
        while (!que.empty()) {
            Vertex *vet = que.front();
            que.pop();          // 队首顶点出队
            res.push_back(vet); // 记录访问顶点
            // 遍历该顶点的所有邻接顶点
            for (auto adjVet : graph.adjList[vet]) {
                if (visited.count(adjVet))
                    continue;            // 跳过已被访问的顶点
                que.push(adjVet);        // 只入队未访问的顶点
                visited.emplace(adjVet); // 标记该顶点已被访问
            }
        }
        // 返回顶点遍历序列
        return res;
    }

    void printVec(vector<Vertex *> vec){
        for(Vertex *vet : vec){
            cout<< vet -> val <<"  ";
        }
        cout<<endl;
    }

};

int main(){

    Vertex* v0 = new Vertex(0);
    Vertex* v1 = new Vertex(1);
    Vertex* v2 = new Vertex(2);
    Vertex* v3 = new Vertex(3);
    Vertex* v4 = new Vertex(4);

    vector<vector<Vertex*>> edges = {{v0, v1}, {v0, v2}, {v1, v2}, {v2, v3}, {v3, v4}};
    GraphAdjList graph(edges);
    graph.printVec(graph.graphBFS(graph, v0));
    return 0;
}
```

#### 运行结果

```c++
0  1  2  3  4
```

## 深度优先搜索（DFS）

详细信息可见 https://www.hello-algo.com/chapter_graph/graph_traversal/#932

```c++
/* 深度优先遍历辅助函数 */
void dfs(GraphAdjList &graph, unordered_set<Vertex *> &visited, vector<Vertex *> &res, Vertex *vet) {
    res.push_back(vet);   // 记录访问顶点
    visited.emplace(vet); // 标记该顶点已被访问
    // 遍历该顶点的所有邻接顶点
    for (Vertex *adjVet : graph.adjList[vet]) {
        if (visited.count(adjVet))
            continue; // 跳过已被访问的顶点
        // 递归访问邻接顶点
        dfs(graph, visited, res, adjVet);
    }
}

/* 深度优先遍历 */
// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
vector<Vertex *> graphDFS(GraphAdjList &graph, Vertex *startVet) {
    // 顶点遍历序列
    vector<Vertex *> res;
    // 哈希集合，用于记录已被访问过的顶点
    unordered_set<Vertex *> visited;
    dfs(graph, visited, res, startVet);
    return res;
}
```

#### 完整代码

```c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>

using namespace std;

struct Vertex{
    int val;
    Vertex(int value):val(value){}
};

class GraphAdjList{
private:
    unordered_map<Vertex*, vector<Vertex*>> adjList;

public:
    GraphAdjList(vector<vector<Vertex*>> &edges){
        for(vector<Vertex*> vec : edges){
            addVertex(vec[0]);
            addVertex(vec[1]);
            addEdges(vec[0], vec[1]);
        }
    }

    void addVertex(Vertex* vets){
        if(adjList.count(vets)) return;
        adjList[vets] = vector<Vertex*>();
    }

    void addEdges(Vertex* vet1, Vertex* vet2){
        if(!adjList.count(vet1) || !adjList.count(vet2) || vet1 == vet2) return;
        adjList[vet1].push_back(vet2);
        adjList[vet2].push_back(vet1);
    }

    /* 深度优先遍历辅助函数 */
    void dfs(GraphAdjList &graph, unordered_set<Vertex *> &visited, vector<Vertex *> &res, Vertex *vet) {
        res.push_back(vet);   // 记录访问顶点
        visited.emplace(vet); // 标记该顶点已被访问
        // 遍历该顶点的所有邻接顶点
        for (Vertex *adjVet : graph.adjList[vet]) {
            if (visited.count(adjVet))
                continue; // 跳过已被访问的顶点
            // 递归访问邻接顶点
            dfs(graph, visited, res, adjVet);
        }
    }

    /* 深度优先遍历 */
    // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点
    vector<Vertex *> graphDFS(GraphAdjList &graph, Vertex *startVet) {
        // 顶点遍历序列
        vector<Vertex *> res;
        // 哈希集合，用于记录已被访问过的顶点
        unordered_set<Vertex *> visited;
        dfs(graph, visited, res, startVet);
        return res;
    }

    void printVec(vector<Vertex *> vec){
        for(Vertex *vet : vec){
            cout<< vet -> val <<"  ";
        }
        cout<<endl;
    }

};

int main(){

    Vertex* v0 = new Vertex(0);
    Vertex* v1 = new Vertex(1);
    Vertex* v2 = new Vertex(2);
    Vertex* v3 = new Vertex(3);
    Vertex* v4 = new Vertex(4);
    Vertex* v5 = new Vertex(5);
    Vertex* v6 = new Vertex(6);

    vector<vector<Vertex*>> edges = {{v0, v1}, {v0, v3}, {v1, v2}, {v2, v5}, {v4, v5},{v5, v6}};

    GraphAdjList graph(edges);

    graph.printVec(graph.graphDFS(graph, v0));


    return 0;
}
```

#### 运行结果

```c++
0  1  2  5  4  6  3
```



