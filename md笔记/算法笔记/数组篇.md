<h1>第一天</h1>

<h3>（一）数组：二分查找法
<h5>对应力扣 <a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a></h5>

<h5>定义三个变量left、right、middle，顾名思义，left指数组左边的下标，right指数组右边的下标，middle代表正中间的下标(left+right)/2；</h5>
<h5>初始情况，left=0,right=数组长度-1</h5>

<h5>每次target值都与middle进行比较，如果比middle大，代表target在数组的右侧，此时移动left的位置，使他等于当前middle+1的位置，为什么不是middle的位置？因为我们这个范围是一个闭区间，如果我们吧left移到middle的位置，此时程序还会再从middle位置开始找，但是target并不在middle位置，因此我们没有必要将left移动到middle位置，而是应该移动到middle+1的位置；如果target小于middle，代表target在数组的左侧，此时将right移动到middle-1的位置；如果target=middle，则直接输出当前middle的值就可以了。
</h5>
<h5>在while循环完，如果都没有使target=middle，则输出-1，代表没找到target</h5>


```c++
int search(vector<int>& nums, int target)
{
    int left=0;
    int right=nums.size()-1;
    while(left<=right)
    {
      	//这个地方加上left是防止middle溢出
        int middle=left+(right-left)/2;
        if(nums[middle]>target)
        {
            right=middle-1;
        }
        else if(nums[middle]<target)
        {
            left=middle+1;
        }
        else
        {
            return middle;
        }
    }
    return -1;
}
```

<h3>（二）数组：移除元素
<h5>对应力扣 <a href="https://leetcode.cn/problems/remove-element/description/">27. 移除元素</a></h5>

<h5>本题使用“双指针”，其实靠erase函数也可以快速实现数组元素的删除，本题目的在于理解erase函数的实现原理；在创建数组时会在内存中开辟一定的空间，删除元素我们是无法删除相应的那个空间，所以c++实现的操作是将后面的值覆盖到前面，虽然空间大小没变，但内置的计数器会执行相应的操作，这就是使用size()函数会返回新的数组长度的原因</h5>
<h5>本题我们的删除操作也是后面的值覆盖给前面，但是这种覆盖操作会使用两层for循环，时间复杂度是O(n^2)，所以我们引入“双指针”只进行一层for循环，减少复杂度 </h5>
<h5>我们定义两个下标，read和write，简单来说read负责找到val，write负责覆盖操作；在for循环中，read如果没有找到val，此时read和write会一起前进，值得注意的一点是，其实write的+1操作是要先于read；如果read找到了val，那么write不会前进，以此实现覆盖操作。最好通过画图的形式验算；当for循环进行完，此时write的位置就是当前新数组的长度，返回即可。</h5>


```c++
int removeElement(vector<int>& nums, int val) {
    int read, write;
    write = 0;
    for (read = 0; read < nums.size(); read++) {
        if (nums[read] != val) {
            nums[write] = nums[read];
            write++;
        }
    }
    return write;
```

<h1>第二天</h1>
<h3>（三）数组：有序数组的平方

<h5>对应力扣 <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977.有序数组的平方</a></h5>

<h5>本地最简单的做法是吧每一个元素先平方，然后把他们放入一个新数组中，使用sort排序并返回。这里介绍“双指针”方法。因为数组元素是有序排序的，并且元素中会有负数，所以我们易知，平方后最大的元素必定在原始数组的两侧，我们定义两个指针i和j，以此从数组两头开始比较。如果pow(nums[i],2)>pow(nums[j],2)把pow(nums[i],2)放入结果数组result的末尾（result数组一定要初始化，长度与nums相同，再定义一个下标k），然后i++，k--；如果pow(nums[i],2)<=pow(nums[j],2),就把pow(nums[j],2)放在result数组末尾，然后j--，k--；直到i<=j跳出循环，返回新数组</h6>

```c++
vector<int> sortedSquares(vector<int>& nums) {
    vector<int>result(nums.size(),0);
    int k=nums.size()-1;
    for(int i=0,j=nums.size()-1;i<=j;)
    {
        if(pow(nums[i],2)>pow(nums[j],2))
        {
            result[k--]=pow(nums[i],2);
            i++;
        }
        else
        {
            result[k--]=pow(nums[j],2);
            j--;
        }
    }
    return result;
}
```

<h3>（四）数组：长度最小的子数组

<h5>对应力扣<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组</a></h5>

<h5>本题依然采用“双指针”的方法，不过这要引出一个概念“滑动窗口的概念,滑动窗口简单来说就是通过移动两个指针改变中间数组的范围，从而找到对应的值。不过滑动窗口一般用于寻找子数组，也就是连续的元素</h5>

<h5>本题定义了两个“指针”i和j，i是起始“指针”，是滑动窗口的左边界；j是末尾“指针”，代表滑动窗口的右边界；他们均从数组起点出发，j指针会快一些。</h5>

<h5>一旦发现滑动窗口之间数组的和sum大于target，此时j指针停止移动，并记录当前滑动窗口数组的长度也就是j-i+1，然后i指针开始移动，因为i向前移动，所以此时的sum需要减去num[i]的值，这才得到新的滑动窗口sum值，重复此步骤，直到j=num.size()，并且不再进行while循环，返回最小的长度值result，如果result还是等于刚赋值时候的值，则返回0。

```c++
int minSubArrayLen(int target, vector<int>& nums) {
    int i,j,sum,result;
    //result要设一个很大的值
    i=0; sum=0; result=INT32_MAX;
    for(j=0;j<nums.size();j++)
    {
        sum+=nums[j];
        while(sum>=target)
        {
            int subL=j-i+1;
            result=min(subL,result);
            sum-=nums[i];
            i++;
        }
    }
    //如果result没有更新，就返回0
    return result==INT32_MAX?0:result;
}
```

<h3> （五）数组：螺旋矩阵II
<h5>对应力扣 <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59.螺旋矩阵II</a></h5>

<h5>本题的难度在于从外到内数组的遍历。由题我们需要从外到内填充数字，因此我们需要考虑四个角上的数字是交给哪个for循环处理（肯定有四个for循环），我们采取的策略是左闭右开，就是当前for循环只处理左边角上的数字。</h5>

<h5>我们定义一个变量loop用于计算有几次环四周循环，比如n=3，loop就等于1，代表有一次环四周循环，余1，代表数组最中间无法循环到，需要单独赋值；我们定义startY和startX当做i和j的起点，每进行完一次while循环（环四周一圈），均进行++操作；我们还定义变量offset，他代表我们的“截止位置”（可能有点抽象，但画个图其实很好理解），上边界和右边界很自然的是++操作，只是下边界和左边界需要进行--操作，也就是倒过来，此时i和j不需要赋初始值，因为上面两个for循环其实给i和j赋值了（i和j都等于n-offset）；定义了count变量，用于放入nums数组内</h5>

<h5>我们还需要判断一个东西，那就是n是奇数还是偶数（前面其实提过）因为如果n是奇数，最中间是没法进循环的，所以我们需要单独赋值，因为已经进行完while循环了，所以只需要把最后的count（其实也不叫最后的count，只是count经过++有数值了）赋值给nums最中间的元素</h5>



```c++
vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>>nums(n,vector<int>(n,0));
        int startX=0;
        int startY=0;
        int offset=1;
        int count=1;
        int loop=n/2;
        int i,j;
        i=0; j=0;
        while(loop--)
        {
            //这个地方一定要搞清楚i，j的定义，我们是先决定第几行，其次才是第几列，不是坐标轴的X和Y
            //所以顺序是0行的第0,1,2；第1行的0,1,2；第2行的0,1,2
            j=startY;
            i=startX;
            for(j;j<n-offset;j++)
            {
                nums[i][j]= count;
                count++;
            }
            for(i;i<n-offset;i++)
            {
                nums[i][j]=count;
                count++;
            }
            for(;j>startY;j--)
            {
                nums[i][j]=count;
                count++;
            }
            for(;i>startX;i--)
            {
                nums[i][j]=count;
                count++;
            }
            startX++;
            startY++;

            offset+=1;
        }
        if(n%2!=0)
        {
            nums[n/2][n/2]=count;
        }
        return nums;
    }
```

<h1>总结</h1>

<h5>这五道题有三道题都使用了“双指针”这个方法，他最本质的作用是用一层for循环解决两层for循环的事情，减少时间复杂度。</h5>

<h5>其次“滑动窗口”一般用于解决子数组的问题（连续数组），通过移动左右“指针”，改变子数字构成，找到问题的解。</h5>

<h5>螺旋矩阵II很考验循环的使用，主要在于边界值的判定，本身理解难度并不高，但是想法很难得

