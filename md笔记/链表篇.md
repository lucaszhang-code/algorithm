<h1>第三天</h1>

<h3>基础复习
<h5>构建一个链表，我们最开始做的操作就是链表节点的定义，这里给出通用代码
<h5>详细信息可以在<a href="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list/">“Hello 算法”链表章节了解</a>
```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
<h5>还需要明确一点，操作任何一个节点都需要知道当前节点的上一个节点，这就跟链表的定义有关了；只有你明确这一点，那后面所有增删改查的操作都是围绕此展开的

<h3>链表：1.移除链表元素
<h4>对应力扣 <a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203.移除链表元素</a></h4>
<h5>本题其实就是简单的链表操作，可以分为两个步骤：（1）便利链表，找到要求的val值 （2）改变链表的指向关系，从而删除节点 （3）释放删除的节点
<h5>本题存在两种解法（1）单独考虑头结点 （2）虚拟节点
<h4>单独考虑头结点
<h5>如果头结点的值就是对应的val并且头结点不为空，我们其实就是让头结点等于头结点的下一个节点head=head->next，当然别忘了删除旧头结点的值，这里我们定义了tmp节点用于接收旧头结点，到时候直接删除tmp就可以了；
此时旧头结点已经删去，我们定义cur节点遍历整个链表进行删除操作，这个地方直接看代码没问题,很好理解的
<img src="./链表/节点删除.png">
```c++
ListNode* removeElements(ListNode* head, int val) {
    //移除头结点
    while(head!=NULL && head->val==val)
    {
        ListNode* tmp=head;
        head=head->next;
        delete tmp;
    }
    ListNode *cur=head;
    while(cur!=NULL && cur->next!=NULL)
    {
        if(cur->next->val==val)
        {
            ListNode* tmp=cur->next;
            cur->next=cur->next->next;
            delete tmp;
        }
        else
        {
            cur=cur->next;
        }
    }
    return head;
}
```

<h4>（2）虚拟节点
<h5>第一种方法我们需要单独考虑头结点的删除情况，虽然并不麻烦，但是代码并不统一，其实说白了虚拟节点就是在头结点前面再创建一个节点
因为前面讲过，添加、删除节点都是需要借助前面一个节点，所以如果我们在头结点前面添加一个节点，就能像普通节点一样操作
<h5>这里我们进行虚拟节点的设置，先给虚拟节点dummyHead设置一个值，然后让他下一个位置指向头结点，我们的cur节点就可以从虚拟节点开始便利了
```c++
ListNode* dummyHead=new ListNode(0); //设置一个虚拟头结点
dummyHead->next=head; //把虚拟头结点放在head的前面
ListNode* cur=dummyHead;
```
<h5>后面的操作其实就和普通节点的删除一样，通过cur节点遍历，发现cur->next->val==val 就让cur->next=cur->next->next
从而跳过cur->next节点，实现删除，别忘了释放节点。那个操作画图很好理解
<h5>最后一步应该返回虚拟节点后的头结点，因为此时旧头结点有可能被删除，虚拟节点后的节点一定是头节点

```c++
ListNode* removeElements(ListNode* head, int val) {
   ListNode* dummyHead=new ListNode(0); //设置一个虚拟头结点
   dummyHead->next=head; //把虚拟头结点放在head的前面ListNode* cur=dummyHead;
   while(cur->next!=NULL)
   {
       if(cur->next->val==val)
       {
           ListNode* tmp=cur->next;
           cur->next=cur->next->next;
           delete tmp;
       }
       else
       {
           cur=cur->next;
       }
   }
   //返回新链表的头结点
    return dummyHead->next;
}
```

<h3>链表：2.设计链表
<h4>对应力扣 <a href="https://leetcode.cn/problems/design-linked-list/solutions/281357/707-she-ji-lian-biao-cyu-yan-chao-xiang-xi-ban-ben/">707.设计链表</a>
<h5>这个案例非常重要，它包括了链表的增删改查，非常有意义，请务必吃透这道题
<h5>首先是链表的定义，这里再放一次加深影响
```c++
public:
    struct NodeList{
        int val;
        NodeList* next;
        NodeList(int x):val(x),next(NULL){}
    };
```
<h5>因为在整个程序中我们都会使用两个变量，一个是虚拟头结点_dummyHead，另一个是链表的长度_size，所以所以别忘了定义和初始化
```c++
private:
    int _size;
    NodeList* _dummyHead;
```
```c++
//初始化
    MyLinkedList() {
        _dummyHead = new NodeList(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
       _size = 0;
    }
```
<h5>请注意，第0个节点是物理意义上的第一个节点；如果index的值小于0或者他大于了链表的长度，直接返回-1
<h5>while循环就是到达index个节点，到达后退出while循环，返回cur的值就可以了，这里还要强调cur是从虚拟节点出发，
你可以理解是从-1号位置出发，所以不需要index-1
```c++
    //获取第n个链表的值
    int get(int index) {
        if(index<0||index> _size-1)
            return -1;
        NodeList* cur=_dummyHead->next;
        while(index)
        {
            cur=cur->next;
            index--;
        }
        return cur->val;
    }
```

<h5>我们通过newNode节点接收值，这个地方注意顺序，先让newNode连接_dummyHead->next，再让_dummyHead->newNode，如果顺序错误
会导致节点无法连接
<img src="./链表/节点连接.png">
```c++
    //头部插入节点
    void addAtHead(int val) {
        NodeList* newNode=new NodeList(val);
        //注意顺序问题
       newNode->next=_dummyHead->next;
       _dummyHead->next=newNode;
       _size++;
    }
```

<h5>没什么好说的，cur通过while循环遍历链表，直到cur->next==NULL 就代表cur已经到了链表末尾，此时令cur->next=newNode 就可以了

```c++
    //在尾部插入节点
    void addAtTail(int val) {
        NodeList* cur=_dummyHead;
        NodeList* newNode=new NodeList(val);
        while(cur->next!=NULL)
        {
            cur=cur->next;
        }
        cur->next=newNode;
        _size++;
    }
```

<h5>这里相比头结点和尾结点添加唯一的区别就是要判断index值的有效性，其他没什么说的，看代码就行了

```c++
    //在第index个节点之前添加元素
    void addAtIndex(int index, int val) {
        if(index > _size) return;
        if(index < 0) index = 0;
        NodeList* cur=_dummyHead;
        NodeList* newNode=new NodeList(val);
        while(index--)
        {
            cur=cur->next;
        }
        newNode->next=cur->next;
        cur->next=newNode;
        _size++;
    }
```

<h5>跟移除元素那道题很像，看代码就行了，别忘了释放内存

```c++
    //在index节点之前删除节点
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        NodeList* cur=_dummyHead;
        while(index--)
        {
            cur=cur->next;
        }
        NodeList* tmp=cur->next;
        cur->next=cur->next->next;
        delete tmp;
        _size--;
    }
```

